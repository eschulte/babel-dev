---
title: DONE sha1 hash based caching
layout: default
---

<div id="outline-container-sha1-caching" class="outline-3">
<h3 id="sha1-caching"><a name="sec-1" id="sec-1"></a><span class="done DONE"> DONE</span> sha1 hash based caching </h3>
<div class="outline-text-3" id="text-sha1-caching">

<ul>
<li>
State "DONE"       from "STARTED" <span class="timestamp-wrapper"> <span class="timestamp">2009-12-22 Tue 14:42</span></span>

</li>
</ul>

<p>This has been implemented.  Results can now be cached using the
<code>:cache</code> header argument.  See the following example.
</p>
<pre class="example">
#+begin_src emacs-lisp :cache yes
  (+ 1 2)
#+end_src

#+results[e1b5...]:
: 3
</pre>



</div>

<div id="outline-container-1.1" class="outline-4">
<h4 id="sec-1.1">historical </h4>
<div class="outline-text-4" id="text-1.1">

<p>So we now have two caching solutions, one which is entirely
in-buffer using sha1 hashes stuffed into the resname lines, and
another which saves the results either in RAM or optionally on
disk.  It is not immediately clear which combination of the two
approaches would be best.
</p>
<dl>
<dt>[EMS]</dt><dd>
I find the saving of cached results in external files to
be very upsetting.  It pollutes the user's disk, and it breaks
what is to me a very fundamental part of org-mode, namely the
fact that all data is saved in plain text in org-mode files.

<p>
Currently I'm leaning towards some combination of file-local
variable (RAM) caching and in-buffer caching.  I have more
comments in-line below.
</p>
<dl>
<dt>[DED]</dt><dd>
I agree about caching to external files. And now that
the hash is hidden in the resname, I think we
definitely want the in-buffer mechanism. Apart from
anything else it improves the mechanism by which we
decide whether or not to over-write existing results.

<p>
The only slight drawback I can see is export: someone who
doesn't want the results in their org file is forced to
regenerate them on every export.
</p>
</dd>
<dt>[EMS]</dt><dd>
alright, that sounds good to me.  I can't think of a
good solution to the export problem right now.  The approach
taken in org-exp-blocks &ndash; suggested by Carsten &ndash; is to add
the hash to the file name where the results were stored, so I
guess that could be an option, but it would be fairly
intrusive, and it would share the problem of saving state
outside of the actual org-mode buffer.  So if you don't
object, I'll merge in the in-buffer caching, and we can keep
the export caching as an open issue, then possibly add the
RAM/local-variable caching on top (which seems like it only
require a couple of lines of code).

</dd>
</dl>
</dd>
</dl>
<ul>
<li id="sec-1.1.1">How well do org buffers function with large folded tables? <br/>

<p>
I have no idea.  Emacs seems to be pretty capable of handling huge
files, but once we get to millions of lines there would probably
be some noticeable delays, and I doubt hiding the results behind
an overlay would help.
</p>
<p>
Maybe this would be a good place for some LOB functions.  One for
serializing data and one for reading in serialized data.  I'm
familiar with <a href="http://www.yaml.org/">YAML</a> which at least has ruby, python (and I believe
elisp) bindings, so that's my first thought, but there are
probably more efficient solutions.
</p>
<p>
Given one function for writing to a file, taking a piece of data
and a file-name and another function for reading from a file given
a file name that should be sufficient for most <b>large</b> storage
needs.  And there's also of course SQL support in org-babel.
</p>
</li>
<li id="sec-1.1.2">cache in buffer <br/>
<ul>
<li id="sec-1.1.2.1">Plus <br/>
<ul>
<li>
Fits cleanly into existing org-babel paradigm.
<ul>
<li>
simple to implement &ndash; minimal code changes
</li>
<li>
doesn't rely on anything <i>external</i> to the org-mode file
</li>
</ul>
</li>
<li>
Persistent across emacs sessions
</li>
</ul>
</li>
<li id="sec-1.1.2.2">Minus <br/>
<ul>
<li>
I don't think it will work for export will it?
<ul>
<li>
This does work for exporting results.  If a result line is
already in the buffer then it will be used instead of
re-evaluation of the result on export.  <b>note</b> I did however
notice two bugs when checking this out which I just pushed up
a fix to in the ems-babel branch.
</li>
<li>
So still a slight drawback, as the results must be in the org
buffer.
</li>
</ul>
</li>
<li>
The result is editable; no promise that repeat evaluation will
give the original result.  true, but that is also true of
results stored in local variables (RAM) or on disk &ndash; although
admittedly it would be harder in those cases.  It would be cool
if we could automatically remove the hash when a result is
edited by hand&hellip;
</li>
<li>
[Therefore difficult to confirm that cache is working] nope,
I've tested it and it works :)
</li>
<li>
Not good for large tables, yes storing large tables in org-mode
buffers can be a pain, perhaps some sort of result folding
would be generally useful &ndash; beyond cached results
</li>
<li>
sha1 hashes are ugly and not-for-humans: hide them? yes, they
are hidden in the most recent version in branch ems-babel.  If
you need to know the hash value for some reason pressing <code>C-c         C-c</code> on the small visible portion of the hash will copy it to
your kill ring
</li>
</ul>
</li>
</ul>
</li>
<li id="sec-1.1.3">cache in RAM <br/>
<ul>
<li id="sec-1.1.3.1">Plus <br/>
<ul>
<li>
Result is not editable &ndash; without editing local variables
</li>
<li>
Good for very large tables &ndash; as long as we don't mind
persisting large tables in memory
</li>
<li>
Fastest of the three
</li>
</ul>
</li>
<li id="sec-1.1.3.2">Minus <br/>
<ul>
<li>
Not part of babel paradigm (but should be very unobtrusive)
</li>
<li>
Not persistent across emacs sessions
<ul>
<li>
Not sharable (impossible to send a file to someone else and
include cached results)
</li>
</ul>
</li>
<li>
user can't read cached data
</li>
</ul>
</li>
</ul>
</li>
<li id="sec-1.1.4">cache on disk <br/>
<ul>
<li id="sec-1.1.4.1">Plus <br/>
<ul>
<li>
Good for large tables
</li>
<li>
Result is not easily editable
</li>
<li>
Persistent across emacs sessions
</li>
</ul>
</li>
<li id="sec-1.1.4.2">Minus <br/>
<ul>
<li>
Not currently part of babel paradigm
<ul>
<li>
(but we will probably want to implement external table
access) meaning tables in foreign org-mode files? because I
think that is already implemented.  If some other sort of
foreign table then I'm not sure what you mean.
</li>
<li>
Not sharable (impossible to send a file to someone else and
include cached results)
</li>
</ul>
</li>
<li>
pollutes user's directories with new files
</li>
<li>
saves state outside of the org-mode buffer
</li>
<li>
no longer "everything in plain text"
</li>
<li>
currently saving data in /tmp directories where it won't
survive reboot
</li>
<li>
using <code>(format "%S" object)</code> to serialize data will not work
for large lists/tables
</li>
<li>
elisp may not be the ideal serialization language
</li>
<li>
the cached data is not visible or readable by the user
</li>
</ul>
</li>
</ul>
</li>
<li id="sec-1.1.5">How do we distinguish a nil result from a lack of a cached result? <br/>

<blockquote>

<p>I wonder if we should consider some cashing of images, also for
export.  I think we could have an alist with sha1 hashes as keys and
image files as values.  The sha1 hash could be made from the entire
code and the command that is used to create the image..
</p>
<p>
&ndash; Carsten
</p>
</blockquote>


<blockquote>

<p>(sha1 stuff) seems to work.
</p>
<p>
org-feed.el has a (require 'sha1) and org-publish.el uses it too.
</p>
<p>
&ndash; Bernt
</p>
</blockquote>


</li>
</ul>
</div>
</div>
</div>
