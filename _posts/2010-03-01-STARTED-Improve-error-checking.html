---
title: STARTED Improve error checking
layout: default
---

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="todo STARTED"> STARTED</span> Improve error checking </h2>
<div class="outline-text-2" id="text-1">

<ul>
<li>
State "STARTED"    from "TODO" <span class="timestamp-wrapper"> <span class="timestamp">2010-03-01 Mon 10:00</span></span>
</li>
<li>
State "TODO"       from "DEFERRED" <span class="timestamp-wrapper"> <span class="timestamp">2010-03-01 Mon 05:49</span></span>
</li>
</ul>


<p>
Current solution for :results value mode:
</p><ul>
<li>
store shell exit code and stderr
</li>
<li>
if non-zero exit code:
<ul>
<li>
write stderr to <b>Org-Babel Error Output</b>
</li>
<li>
display <b>Org-Babel Error Output</b>
</li>
</ul>
</li>
</ul>


<p>
:results output mixes stderr with stdout and does not otherwise notify on error.
</p>
<p>
Questions:
</p><ul>
<li>
What should we do when stderr is non-empty but exit code is
zero?
</li>
<li>
What should we do in the case of shell non-session :results value?
</li>
<li>
What should we do in the case of :session?
</li>
</ul>



</div>

<div id="outline-container-1_1" class="outline-3">
<h3 id="sec-1_1">Return error structure? </h3>
<div class="outline-text-3" id="text-1_1">

<p>Could use the following at outset of org-babel-insert-result.
</p>


<pre class="src src-emacs-lisp">(<span class="org-keyword">if</span> (and (consp result) (eq (first result 'org-babel-error-flag)))
    (<span class="org-keyword">progn</span>
      (message <span class="org-string">"Shell command exited with error %d"</span> (second result))
      (<span class="org-keyword">unless</span> (= (length (third result)) 0)
        (<span class="org-keyword">let</span> (error-buffer (get-buffer-create <span class="org-string">"*Org-Babel Error Output"</span>))
          (<span class="org-keyword">with-current-buffer</span> error-buffer (insert (third result)))
          (display-buffer error-buffer))))
    )
</pre>



</div>

</div>

<div id="outline-container-1_2" class="outline-3">
<h3 id="sec-1_2">older notes </h3>
<div class="outline-text-3" id="text-1_2">

<p>E.g. when trying to execute sass block, I did not have sass
installed, and so shell-command returned code 127, but org-babel
did not warn me that anything had gone wrong.
I expect it will be hard to do this properly, but ultimately it
would be nice to be able to specify somewhere to receive STDERR,
and to be warned if it is non-empty.
</p>
<p>
Probably simpler in non-session evaluation than session? At least
the mechanism will be different I guess.
</p>
<p>
R has a try function, with error handling, along the lines of
python. I bet ruby does too. Maybe more of an issue for functional
style; in my proposed scripting style the error just gets dumped to
the org buffer and the user is thus alerted.
</p>
<p>
For now I think the current behavior of returning any error
messages generated by the source language is sufficient.
</p>
</div>

</div>

<div id="outline-container-1_3" class="outline-3">
<h3 id="sec-1_3">Error checking in R sessions </h3>
<div class="outline-text-3" id="text-1_3">

<p>A simple thing to do is to wrap the R code in try(&hellip;), as in the
patch below. That results in some improved behaviour:
</p><ul>
<li>
You get the error message from R
</li>
<li>
Execution halts at first error
E.g.
</li>
</ul>




<pre class="src src-R"><span class="org-function-name">f</span> <span class="org-constant">&lt;-</span> <span class="org-keyword">function</span>() {
    cat(<span class="org-string">"hello\n"</span>)
    x <span class="org-constant">&lt;-</span> log(<span class="org-string">"a"</span>)
    cat(<span class="org-string">"bye\n"</span>)
}
</pre>




<pre class="src src-R">f()
</pre>





</div>

<div id="outline-container-1_3_1" class="outline-4">
<h4 id="sec-1_3_1">patch </h4>
<div class="outline-text-4" id="text-1_3_1">

<p>diff &ndash;git a/contrib/babel/lisp/langs/org-babel-R.el b/contrib/babel/lisp/langs/org-babel-R.el
index 1ef21db..45f8409 100644
&mdash; a/contrib/babel/lisp/langs/org-babel-R.el
+++ b/contrib/babel/lisp/langs/org-babel-R.el
@@ -103,8 +103,8 @@ last statement in BODY, as elisp."
(out-tmp-file (make-temp-file "R-out-functional-results")))
(case result-type
(output
</p><ul>
<li>
          (with-temp-file in-tmp-file (insert body))
</li>
<li>
          (shell-command-to-string (format "R &ndash;slave &ndash;no-save &lt; '%s' &gt; '%s'"
</li>
<li>
          (with-temp-file in-tmp-file (insert (concat "try({" body "})")))
</li>
<li>
          (shell-command-to-string (format "R &ndash;slave &ndash;no-save &lt; '%s' &gt; '%s' 2&gt;&amp;1"
in-tmp-file out-tmp-file))
(with-temp-buffer (insert-file-contents out-tmp-file) (buffer-string)))
(value
</li>
</ul>

<p>@@ -124,7 +124,7 @@ last statement in BODY, as elisp."
(format "write.table(.Last.value, file=\"%s\", sep=\"\\t\", na=\"nil\",row.names=FALSE, col.names=%s, quote=FALSE)" tmp-file (if column-names-p "TRUE" "FALSE"))
org-babel-R-eoe-indicator) "\n"))
(output
</p><ul>
<li>
               (mapconcat #'org-babel-chomp (list body org-babel-R-eoe-indicator) "\n"))))
</li>
<li>
               (mapconcat #'org-babel-chomp (list (concat "try({" body "})") org-babel-R-eoe-indicator) "\n"))))
(raw (org-babel-comint-with-output buffer org-babel-R-eoe-output nil
(insert full-body) (inferior-ess-send-input)))
broke results)
</li>
</ul>

<p>diff &ndash;git a/contrib/babel/lisp/org-babel-ref.el b/contrib/babel/lisp/org-babel-ref.el
index 0e8695f..060f880 100644
&mdash; a/contrib/babel/lisp/org-babel-ref.el
+++ b/contrib/babel/lisp/org-babel-ref.el
@@ -139,7 +139,7 @@ return nil."
('results-line (org-babel-read-result))
('table (org-babel-read-table))
('source-block
</p><ul>
<li>
        (setq result (org-babel-execute-src-block t nil args))
</li>
<li>
        (setq result (org-babel-execute-src-block t (org-babel-get-src-block-info) args))
(if (symbolp result) (format "%S" result) result))
('lob (setq result (org-babel-execute-src-block t lob-info args)))))))
</li>
</ul>
</div>
</div>
</div>
</div>
