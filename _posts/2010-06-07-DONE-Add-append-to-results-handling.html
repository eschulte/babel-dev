---
title: DONE Add =append= to results handling
layout: default
---

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="done DONE"> DONE</span> Add <code>append</code> to results handling </h2>
<div class="outline-text-2" id="text-1">

<ul>
<li>
State "DONE"       from "PROPOSED" <span class="timestamp-wrapper"> <span class="timestamp">2010-06-07 Mon 16:46</span></span>
</li>
<li>
State "PROPOSED"   from "TODO" <span class="timestamp-wrapper"> <span class="timestamp">2010-06-05 Sat 19:11</span></span>
</li>
<li>
State "TODO"       from "PROPOSED" <span class="timestamp-wrapper"> <span class="timestamp">2010-06-05 Sat 19:02</span></span>
</li>
<li>
State "PROPOSED"   from "" <span class="timestamp-wrapper"> <span class="timestamp">2010-04-01 Thu 10:34</span></span>

</li>
</ul>

<p>(implemented while fixing the <a href="#*results==deletion==and==insertion">results deletion and insertion</a> bug)
</p>
<p>
I'm developing general purpose org-babel functions that run queries
for frequently performed analyses.  In some instances it isn't
possible to make the queries completely general, so I'm left with
combining the results of two or more separate calls to the org-babel
functions.
</p>
<p>
This is an example.  Two runs are needed to make a table with coral
abraders and basalt manuports, when there are also basalt abraders and
coral manuports in the data table.  If I set material="('coral',
'basalt')" and class="('abrader','manuport') then I get all four types
of artifact in the results.
</p>



<div class="org-src-container"><label class="org-src-name">artifacts-class-wt(project=112, duration="('event','process')", material="('wood')", class="('charcoal')", start=35, end=61)</label><pre class="src src-R">
&lt;&lt;r-connect-to-data&gt;&gt;

q <span class="org-constant">&lt;-</span> sprintf(<span class="org-string">"SELECT c.context, a.class,
round(sum(a.weight),1) AS weight FROM artifacts a, baglist b,
context c WHERE a.bag = b.bag AND b.context = c.context AND
a.project = %i and b.project = %i and c.project = %i AND a.class IN %s
AND a.material IN %s AND c.context_type = 'cultural' AND c.duration IN %s  AND b.context &gt;= %i AND b.context &lt;= %i group by 1,
2 order by 1, 2"</span>, project, project, project, class, material, duration, start,
end)

art.wt <span class="org-constant">&lt;-</span> dbGetQuery(con, q) 
&lt;&lt;r-disconnect&gt;&gt;
art.wt
</pre></div>




<p>
It would be useful in this case, and perhaps other cases, to have a <code>:results append</code> argument.  An org-mode table would be created if it is absent,
or the function results would be appended to an existing results table
if present.
</p>

</div>

<div id="outline-container-1_1" class="outline-3">
<h3 id="sec-1_1">EMS thoughts </h3>
<div class="outline-text-3" id="text-1_1">


<p>
this seems like a good idea, and should be easy to implement.  The
next step would be to allow pre-pending or insertion at arbitrary
points in the table, or to define combining functions (e.g. if the
result is a scalar rather than a table to sum, or multiply, or
concatenate the values), this then comes full-circle back to maybe the
results block should just be another argument to the code block (which
raises an issue of circular code block calls, and a related issue of
controlling whether a block need be re-run if it's results already
exist in the buffer), and appending shouldn't be explicitly built into
org-babel.
</p>
<p>
Hmm, I see three good options here &ndash; there are certainly more;
</p><ol>
<li>
sort out all issues related to re-running code blocks which already
have in-buffer results s.t. it is possible for a block to reference
it's own results
</li>
<li>
add a simple append option
</li>
<li>
add something like <i>results incorporating</i> functions which could
provide a more generic functionality subsuming appending of
functions
</li>
</ol>
</div>
</div>
</div>
