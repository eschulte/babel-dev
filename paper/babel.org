# -*- mode: org -*-
#+TITLE: A Multi-Language Computing Environment for Literate Programming and Reproducible Research /DRAFT/
#+AUTHOR: Eric Schulte\\University of New Mexico \And Dan Davison\\University of Oxford \AND Thomas Dye\\University of Hawai`i \AND Carsten Dominik\\University of Amsterdam and Radboud University Nijmegen
#+OPTIONS: ^:nil toc:nil H:4
#+STARTUP: oddeven
#+STYLE: <link rel="stylesheet" href="http://cs.unm.edu/~eschulte/classes/emacs.css" type="text/css"/>  
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{attrib}
#+LATEX_HEADER: \usepackage{mathpazo}
#+LATEX_HEADER: \usepackage{thumbpdf}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \Plainauthor{Eric Schulte, Dan Davison, Thomas Dye, Carsten Dominik}
#+LATEX_HEADER: \Shorttitle{Computational Environment for Mixed Prose and Code}
#+LATEX_HEADER: \Keywords{emacs, lisp, org-mode, literate programming, reproducible research, compendium, web}
#+LATEX_HEADER: \Address{Eric Schulte\\Department of Computer Science\\University of New Mexico\\1 University of New Mexico\\Albuquerque, NM 87131\\United States of America\\E-mail: eschulte@cs.unm.edu\\URL: http://cs.unm.edu/$\sim$eschulte/}
#+LATEX_HEADER: \Abstract{We present a new computing environment for authoring mixed natural and computer language documents. In this environment a single hierarchically-organized plain text source file may contain a variety of elements such as code in arbitrary programming languages, raw data, links to external resources, project management data, working notes, and text for publication. Code fragments may be executed in situ with graphical, numerical and text output captured or linked in the file. Export to \LaTeX{}, HTML, \LaTeX{} Beamer, DocBook and other formats permits working reports, presentations and manuscripts for publication to be generated from the file. In addition, functioning pure code files can be automatically extracted from the file. This environment is implemented as an extension to the Emacs text editor and provides a rich set of features for authoring both prose and code, as well as sophisticated project management capabilities.}
#+LaTeX_CLASS: jss


* COMMENT Possible titles
| term                         |     hits |
|------------------------------+----------|
| "reproducible research"      |    24700 |
| "literate programming"       |    74500 |
| "natural language document"  |    98000 |
| "computer language document" |        6 |
| "computer language"          |  2500000 |
| "programming language"       | 15900000 |

** A New Computing Environment for Literate Programming and Reproducible Research

* COMMENT How to export this file to LaTeX

Settings required for export to the Journal of Statistical Software
are found in the =jss= source block.  Run this code block with =C-c
C-c= before exporting.  When done exporting, run the return-to-default
code block to set variables and hooks back to their default values.

** Org-mode LaTeX export to JSS
#+source: jss
#+begin_src emacs-lisp :tangle yes :results silent
  (require 'org-latex)
  (org-add-link-type
   "latex" nil
   (lambda (path desc format)
     (cond
      ((eq format 'html)
       (format "<span style=\"color:black;\">%s</span>" desc))
      ((eq format 'latex)
       (format "\\%s{%s}" path desc)))))
  
  (setq org-babel-default-header-args:org '((:results . "raw silent")
                                            (:exports . "code")))
  
  (add-to-list 'org-export-latex-classes
               '("jss"
                 "\\documentclass[article,shortnames]{jss}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  ;; replace nasty single-quotes returned by R
  (add-hook 'org-export-latex-final-hook
            (lambda ()
              (replace-regexp "’" "'")))
  ;; JSS has its own code formatting style
  (setq org-export-latex-listings nil)
  (setq org-export-latex-verbatim-wrap
        '("\\begin{Code}\n" . "\\end{Code}\n"))
  nil
#+end_src

** Reset to default

#+source: reset-to-default
#+begin_src emacs-lisp
  (setq org-export-latex-verbatim-wrap
        '("\\begin{verbatim}\n" . "\\end{verbatim}\n"))
  (add-hook 'org-export-latex-final-hook nil)
  
#+end_src

#+results: jss
** Original publishing setup
turn on the listings package, and define the =twocolumn= latex class
#+begin_src emacs-lisp :results silent
  (require 'org-latex)
  
  ;; use latex listings for fontified code blocks
  (set-default 'org-export-latex-listings t)
  
  ;; two column export
  (add-to-list 'org-export-latex-classes
               '("twocolumn" "\\documentclass[10pt, twocolumn]{article}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  
  ;; replace nasty single-quotes returned by R
  (add-hook 'org-export-latex-final-hook
            (lambda ()
              (replace-regexp "’" "'")))
  ;; (add-hook 'org-export-latex-final-hook
  ;;           (lambda ()
  ;;               (replace-regexp
  ;;                "href{David==Gillespie==1990,==\\[\\[http://www.gnu.org/software/emacs/calc.html}{http://www.gnu.org/software/emacs/calc.html}\]\]"
  ;;                "href{David Gillespie 1990, http://www.gnu.org/software/emacs/calc.html}{http://www.gnu.org/software/emacs/calc.html}")))
  (add-hook 'org-export-latex-final-hook
            (lambda ()
              (re-search-forward (regexp-quote "file:pascals-triangle.pdf"))
              (forward-line -1)
              (insert "\n#+Caption: Pascal's Triangle \label{pascals-triangle-fig}")))
  
  ;; export the bodies of org-mode blocks
  (setq org-babel-default-header-args:org
        '((:results . "raw silent")))
#+end_src

** HTML publish
#+begin_src emacs-lisp
  (defun <language>-mode () (interactive))
  ;; (setq org-export-htmlize-output-type 'css)
#+end_src

* Introduction
There are a variety of settings in which it is desirable to mix prose,
code, and computational results in a single document.
- /Scientific research/ increasingly involves the use of computational
  tools. Successful communication and verification of research results
  requires that this code is distributed together with results and
  explanatory prose.
- In /software development/ the exchange of ideas is accomplished
  through both shared code and prose; code provides concrete and
  succinct description and prose provides higher level explanation.
  Without proper documentation the usability and future extensibility
  of computational tools are compromised.
- In /pedagogical/ environments it is important for descriptions of
  algorithms or techniques to go hand-in-hand with concrete
  implementations and example output.  These environments include
  in-class presentations, published books and articles, online
  tutorials, and experiential blogs with accompanying instructions.

In each of the situations described above, prose alone in the absence
of code is typically insufficient.  Similarly, code without expository
prose is a less than ideal medium for communication between people. In
this paper we describe the plain text markup language [[latex:proglang][Org-mode]], with a
focus on its provision of a unified environment supporting many
different approaches to composition and application of combined prose
and code (Figure \ref{fig:overview}).  Working in [[latex:proglang][Org-mode]] is an
extension of standard text editing. Thus, trivial usage of [[latex:proglang][Org-mode]] is
nothing more than text editing, from which point the user can start to
add special plain text [[latex:proglang][Org-mode]] elements to the document.  [[latex:proglang][Org-mode]] is
therefore easy to adopt and aims to be a general solution for
authoring projects with mixed computational and natural languages.  It
supports multiple programming languages, export targets, and work
flows.

#+begin_LaTeX
  \usetikzlibrary{shapes,arrows,shadows,decorations,decorations.text,through}
  \tikzstyle{page} = [rectangle, draw, text width=9em,
  text centered, rounded corners,
  node distance=3cm, minimum height=1em,
  font=\tiny,
  fill=blue!20,
  general shadow={
    fill=black!30,
    shadow xshift=0.25cm,
    shadow yshift=-0.25cm
  },
  very thick,
  draw=blue]
  \begin{figure}
    \centering
    \begin{tikzpicture}[->,>=stealth', shorten >=1pt, auto, scale=0.75]
      \node [page] (org) at (0,0) {
        \begin{center}
          \normalsize{Org-mode}
        \end{center}
  \begin{verbatim}
    ,* Plain Text Markup
    - prose composition
    - code composition
    - data analysis
  
    ,#+begin_src sh :tangle run.c
      int main(){
        return 0;
      }
    ,#+end_src
  
    ,#+begin_src R :file fig.pdf
      plot(data)
    ,#+end_src
  
  \end{verbatim}
      };
  
      \node [page] (htm) at (7,1) {
        \begin{center}
          \normalsize{HTML}
        \end{center}
  \begin{verbatim}
    <h1>Plain Text Markup</h1>
    <ul>
    <li>prose composition</li>
    <li>code composition</li>
    <li>data analysis</li>
    </ul>
  \end{verbatim}
      };
  
      \node [page] (tex) at (8,-1) {
        \begin{center}
          \normalsize{\LaTeX{}}
        \end{center}
  \begin{verbatim}
    \Section{Plain Text Markup}
    \begin{itemize}
    \item prose composition
    \item code composition
    \item data analysis
    \end{itemize}
  \end{verbatim}
      };
  
      \node [page] (src) at (-7,0) {
        \begin{center}
          \normalsize{Source Code}
        \end{center}
  \begin{lstlisting}
    int main(){
      return 0;
    }
  \end{lstlisting}
      };
  
      \node [text width=8em] (code-out) at (3.5,-5) {embedded data and
        source code in arbitrary languages};
  
      \node [text width=8em] (code-out) at (-3.5,-5) {raw output,
        tabular data, figures, etc\ldots};
  
      \path (org) edge [loop below] node {\normalsize{Code Evaluation}}
      (org); \path (org) edge node {\normalsize{Export}} (4.5,0); \path (org)
      edge node [above] {\normalsize{Tangle}} (-4.5,0);
    \end{tikzpicture}
    \caption{\proglang{Org-mode} enables both the composition and
      application of code and prose.}
    \label{fig:overview}
  \end{figure}
#+end_LaTeX

With [[latex:proglang][Org-mode]] the entire life cycle of a research or development
project can take place within a single document.  Because [[latex:proglang][Org-mode]] is
language agnostic and the user can mix languages within a document, it
is possible to support the widest variety of projects.  These range
from the single user, who keeps a laboratory notebook
embedded with calculations in [[latex:proglang][Org-mode,]] to the collaborative
work-group tasked with engineering a complex system, which uses
[[latex:proglang][Org-mode]] in conjunction with a modern version control system such as
[[latex:proglang][git]] to build a central repository of code and documentation.  With the
data, code and text of a project stored in a single location which can
be exported to a variety of formats, the future reproducibility of the
work is enhanced without placing a great burden on the
author.

We start by reviewing existing approaches to the combined authoring of
prose and code, including software tools designed to address one or
more of the use cases for mixed natural and computer language
documents (Section \ref{background}).  We then describe the design of
[[latex:proglang][Org-mode]] (Section \ref{design}) and demonstrate some of its uses with
three short examples (Section \ref{examples}).  We conclude with a
discussion of why we believe [[latex:proglang][Org-mode]] constitutes a uniquely
productive environment for authoring mixed prose and code projects
(Section \ref{discussion}).  This document is itself written in
[[latex:proglang][Org-mode]]; the version submitted to the journal was created by
running a single export command.  This command executed the source
code examples and generated the figures before exporting the content
to a LaTeX file marked up according to the journal's specification. The
[[latex:proglang][Org-mode]] source for this paper is available online [fn:5].

* Background
  :PROPERTIES:
  :CUSTOM_ID: background
  :END:
The combined authoring of prose and code has historically been
approached from two different standpoints.

- Literate Programming :: enhances traditional software development by
     embedding code in explanatory essays and encourages treating the
     act of development as one of communication with future
     maintainers.

- Reproducible Research :: embeds executable code in research reports
     and publications, with the aim of allowing readers to re-run the
     analyses described.

We discuss each of these approaches in turn and include a review of
existing software tools that support each technique.

** Literate programming
#+begin_quote
Let us change our traditional attitude to the construction of
programs: Instead of imagining that our main task is to instruct a
computer what to do, let us concentrate rather on explaining to human
beings what we want a computer to do.

\attrib{Donald E. Knuth}
#+end_quote

The technique of /literate programming/ was introduced by Donald Knuth
\citep{web} in the early 1980's, not long after he created the TeX
typesetting software.  Literate programming has been described as aiming to
encourage the author of a computational work to approach the project
"as an essayist, whose main concern is with exposition and excellence
of style."
# need citation with page number
# I hesitate about including this as I find the quote itself
# pretentious and thus of questionable style [DD]

Accordingly, the input files for literate programming tools mix
sections of computer code with sections of natural language typically
marked up in TeX or LaTeX.  The literate programming tool provides
methods to create two types of /view/ into the document; articles of
typeset prose with marked-up code blocks intended for human consumption,
and computer-readable documents of pure source code.  The literate
programming terms for generating these views are /weaving/ and
/tangling/, respectively.  A common feature of literate programming
tools is the ability to organize code blocks differently when
/tangling/ and /weaving/, thereby allowing the programmer to introduce
material to humans in a different order than code is introduced to the
computer.

The original literate programming tool, developed by Knuth, was
[[latex:proglang][WEB]], which consists of two primary programs,
=TANGLE= and =WEAVE= \citep{web}.  This system supported the Pascal
programming language and produced documents typeset with TeX.
Somewhat later, Knuth and Silvio Levy produced a C language version,
[[latex:proglang][cWeb]] \citep{knuth94:_cweb_system_struc_docum}.  A
modern descendent of these tools is [[latex:proglang][noweb]]
\citep{noweb} which is designed to be language independent.  Its
primary programs, =notangle= and =noweave=, are both written in
[[latex:proglang][C]].  Documents produced by =noweave= can be typeset
with TeX, LaTeX, and [[latex:proglang][troff]] or displayed in a web
browser as =HTML=.
# I'm slightly confused here. Is that the same as saying that
# =noweave= is capable of producing LaTeX, troff and HTML output? Does
# =noweave= require latex (mixed with code) as /input/?
Software tools such as [[latex:proglang][WEB]], [[latex:proglang][cWeb]], and [[latex:proglang][noweb]] enable the authoring of
both prose and code, but do not provide facilities for the execution
of code from within documents.  Instead, code intended for execution
is tangled and the resulting source code files are sent to a compiler
or interpreter.

** Reproducible research
#+begin_quote
An article about computational science in a scientific publication is
*not* the scholarship itself, it is merely *advertising* of the
scholarship.  The actual scholarship is the complete software
development environment and complete set of instructions which
generated the figures.

\attrib{David L. Donoho}
#+end_quote

# Needs citation with page number

A research project typically relies upon components such as:
  - the data being studied
  - details of calculations and code used in data analysis
  - methodological conventions and assumptions
  - decisions among alternate analytic paths

However, the documents produced by a research project typically stand
apart from the things they describe and rely upon, which makes it
difficult for other researchers to reproduce the results and to
understand fully the conclusions of the research project. This
situation is problematic because reproducibility of results and
accurate communication are both central to notions of good science.

A software solution to this problem was proposed by
\citet{compendium}, who "introduce the concept of a /compendium/ as
both a container for the different elements that make up the document
and its computations (i.e. text, code, data, ...), and as a means for
distributing, managing and updating the collection."

They summarize the uses and implications of a compendium as follows:

  - it encapsulates the actual work of the author, not just an
    abridged version suitable for publication; 

  - it can display different levels of detail in /derived documents/; 

  - the computations included in it can be re-run by an interested
    reader, potentially with different inputs;

  - it contains explicit computational details that make it easier for
    an interested reader to adapt and extend the methods;

  - it enables programmatic construction of plots and tables; 

  - its components can be treated as data or inputs to software and
    manipulated programmatically in ways perhaps not envisioned by
    the author.

/Reproducible research/ thus approaches mixed natural and
computational language documents from a different direction than
literate programming.  Rather than adding prose to computational
projects, reproducible research seeks to augment publications of
scientific research with the computer code used to carry out the
research.  Whereas literate programming extracts embedded code into an
external file used as input to a compiler or an interpreter, code
embedded in a reproducible research document is intended to be executed as part
of the document generation process.  In this way the data, analysis,
and figures supporting a publication can be generated from the
publication itself.

# The requirements of a tool supporting reproducible research are
# thoroughly explored by Gentleman and Temple Lang, and presented in the
# concept of a /compendium/ \citep{compendium}.  In their formulation a
# compendium is a container that holds the text, code, and raw data
# constituting a scholarly work.  Compendia are intended to facilitate
# the distribution, management, re-creation, and extension of such
# works.

# A compendium would also support a variety of different /views/, where
# /views/ are static documents automatically generated by /running/ the
# compendium.  Examples of views would be an article submitted for
# publication, or a presentation or lecture based on the work.

Gentleman and Temple Lang propose the adoption of compendia as the
new unit of peer review and distribution of scientific work.

#+begin_quote
The compendium concept, and that of reproducible research, has the
potential to improve the state of publication about computational
science. The tools we have proposed and discussed will allow us to
move from an era of advertisement to one where our scholarship itself
is published. This exposes the computations themselves to the
scientific method and enhances the potential for iterative refinement
and extension.  \citep{compendium}
#+end_quote

=Sweave= \citep{sweave} is a modern software tool written in the [[latex:proglang][R]]
statistical programming language \citep{r-software} that can be used
for reproducible research.  [[latex:proglang][Sweave]] and the [[latex:proglang][R]] community at large
inspired the work that led to the /compendium/ idea, and the recent
resurgence of interest in reproducible research owes much to the
success of both [[latex:proglang][R]] and [[latex:proglang][Sweave]].  [[latex:proglang][Sweave]] documents consist of blocks of [[latex:proglang][R]]
code embedded in LaTeX documents.  The [[latex:proglang][R]] functions that make up [[latex:proglang][Sweave]]
execute the embedded [[latex:proglang][R]] code and produce another LaTeX document that
includes the resulting tables, graphical figures, and inline results.
If the [[latex:proglang][Sweave]] document is accompanied by the data files and any other
code that is used, then the reader can trace a result back to the
relevant computations and through to the original data.  The [[latex:proglang][Sweave]]
approach to reproducible research has spawned similar tools, some of
which support statistical languages other then [[latex:proglang][R]], and which target
document preparation systems other than LaTeX, including Open Document
Format and Microsoft Word
\citep{Lenth:2007:SLP,baier07:_excel,kuhn10:_odfweav_packag,lenth09:_statw_users_manual}.

# It might be useful to start this section with Lisp and how bottom-up
# programming changes the language to suit the problem.  So emacs
# turned lisp into a language for writing editors, org-mode turned it
# into a language for parsing hierarchical documents, etc., and babel
# turned it into a language for literate programming and reproducible
# research. (no attempt to be precise or exhaustive here).
* Design of Org-mode
  :PROPERTIES:
  :CUSTOM_ID: design
  :END:
At the core of [[latex:proglang][Org-mode]] is the Emacs text editor \citep{emacs} and
[[latex:proglang][Emacs Lisp]]
\citep{lewis10:_gnu_emacs_lisp_refer_manual}, a dialect of Lisp that
supports the editing of text documents.  The Emacs editor has been under
development since the mid 1970s and is currently at version 23.
[[latex:proglang][Org-mode]] extends Emacs with a simple and powerful markup language
that turns it into a language for creating, parsing, and interacting with
hierarchically-organized text documents.  Its
rich feature set includes text structuring, project management, and a
publishing system that can export to a variety of formats.  Source
code and data are located in active blocks, distinct from text
sections, where "active" here means that code and data blocks can be
/evaluated/ to return their contents or their computational results.
The results of code block evaluation can be written to a named data
block in the document, where it can be referred to by other code
blocks, any one of which can be written in a different computing
language.  In this way, an [[latex:proglang][Org-mode]] buffer becomes a place where
different computer languages communicate with one another.  Like
Emacs, [[latex:proglang][Org-mode]] is extensible: support for new languages can be added
by the user in a modular fashion through the definition of a small
number of [[latex:proglang][Emacs Lisp]] functions.

In the remainder of this section, we first describe [[latex:proglang][Org-mode]] in more detail, focusing
on those features that support literate programming and reproducible
research (Section \ref{org-mode}).  We then describe the syntax of
code and data blocks (Section \ref{syntax}), evaluation of code blocks
(Section \ref{code-blocks}), weaving and tangling of [[latex:proglang][Org-mode]] documents
(Section \ref{export}), and language support facilities (Section
\ref{languages}).

** Structure and content of Org-mode documents
   :PROPERTIES:
   :CUSTOM_ID: org-mode
   :END:

[[latex:proglang][Org-mode]] is an Emacs extension that organizes note taking, task
management, project planning, documentation and authoring.  Its name
comes from its organizing function and the fact that extensions to
Emacs are often implemented as /modes/---software modules that define
the way a user can edit and interact with certain classes of
documents.  [[latex:proglang][Org-mode]] documents are plain text files, usually with the
file name extension /.org/; working in [[latex:proglang][Org-mode]] starts with
conventional text editing and incrementally adds [[latex:proglang][Org-mode]]-specific
features.  Because Emacs has been ported to a large number of operating systems
[[latex:proglang][Org-mode]] can be run on a wide variety of devices and its plain text
documents are compatible between arbitrary platforms.

*** Document structure

The fundamental structure of [[latex:proglang][Org-mode]] documents is the outline,
comprising a hierarchically arranged collection of nodes.  A
document can have a section of text before the first node, which 
is often used for defining general properties of the document
such as a title, and for technical setup.  Following this initial 
section is a sequence of top-level nodes, each of which is the root 
of a subtree of arbitrary depth.
Nodes in the outline are single line headings identified by one or
more asterisks at the beginning of the line.  The number of asterisks
indicates the hierarchical level of the node.

#+begin_src org
  ,* First heading
  ,    Some arbitrary text
  ,* Second heading
  ,** A subsection of the second heading
  ,* Third heading
#+end_src

Each heading line can be followed by arbitrary text,
which gives the document the logical structure of a book or article.  The
hierarchical outline structure can be folded at every node, making it
possible to expose selected sections for quick access or to provide a
structural overview of the document.

*** Metadata on nodes

One of the primary design goals of [[latex:proglang][Org-mode]] was to define a system
that combines efficient note-taking and brainstorming with a task
management and project planning system.  A single [[latex:proglang][Org-mode]] document
can hold the notes together with all the data necessary to keep track
of tasks and projects associated with the notes.  This is accomplished
by assigning metadata to outline nodes using a special syntax.
Metadata for a node can include a task state, like =TODO= or =DONE=, a
priority, and one or more tags, dates, and arbitrary key-value pairs
called properties.  In the following example the top-level node is a
task with state =TODO=, a priority of =A=, and tagged for urgent
attention at work.  The task has been scheduled for 18 August 2010 and
a property indicates that it was delegated to Peter.

#+begin_src org
  ,* TODO [#A] Some task         :@work:urgent:
  ,  SCHEDULED: <2010-08-18 Wed>
  ,  :PROPERTIES:
  ,    :delegated_to: Peter 
  ,  :END:
#+end_src

The task and project management functionality of [[latex:proglang][Org-mode]] is centered
around the metadata associated with nodes.  [[latex:proglang][Org-mode]] provides
facilities to create and modify metadata quickly and efficiently.  It
also provides facilities to search, sort, and filter headlines, to
display a chronological summary of all headlines with date and time
metadata, to
display tabular views of properties at selected headlines, to clock in and out of
headlines defined as tasks, and more.

The outline structure of documents defines a hierarchy of
metadata.  Tags and properties of a node are inherited by its
sub-nodes, and views of the document can be designed that sum or
average the properties inherited by a node.  Code blocks live in this
hierarchy of content and metadata, all of which is accessible to and
can be modified by the code blocks.

*** Special document content

The text following a headline in an [[latex:proglang][Org-mode]] document can be
structured to represent various types of information, including
vectors, matrices, source code, and arbitrary pieces of text.  Vector
and matrix data are represented as tables where the columns are marked
by vertical bars and rows are optionally separated by dashed lines as
shown in the following example.  The Emacs mathematical tool, /calc/,[fn:3] 
can be used to carry out computations in tables.  This feature is
similar to spreadsheet applications, but [[latex:proglang][Org-mode]] uses plain text to
represent both data and formulas.

# Replace "calculator" with "mathematical engine" or something? "calculator" sounds very 1980s...
# GNU's calc page calls calc a "mathematical tool"  TD

#+begin_src org
  ,| Name 1 | Name 2 | ... | Name N |
  ,|--------+--------+-----+--------|
  ,| Value  | ...    | ... | ...    |
  ,| ...    | ...    | ... | ...    |
#+end_src

** Code and data block extensions
    :PROPERTIES:
    :CUSTOM_ID: code-blocks
    :END:

Both code and data blocks are /active/ in [[latex:proglang][Org-mode]] documents.  This
means that code blocks can be evaluated and their results written to
the document as [[latex:proglang][Org-mode]] results blocks.  These blocks can interact with
both data and code blocks through a simple and powerful variable
passing system.

*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax
    :END:

# DONE: And #TBLNAME <- I don't think we need to cover all possible
#                       syntax [Eric]

Data blocks that are preceded by a line that begins with =#+results:=,
and are
followed by a name unique within the document, can be accessed by code
blocks. These can be /tables/, /example blocks/, or /links/.
#+begin_src org
  ,#+results: tabular-data
  ,| 1 |  2 |
  ,| 2 |  3 |
  ,| 3 |  5 |
  ,| 4 |  7 |
  ,| 5 | 11 |
  
  ,#+results: scalar-data
  ,: 9
  
  ,#+results: linked-data
  ,[[http://external-data.org]]
#+end_src

Active code blocks are marked with a =#+source:= line, followed by a
name unique within the document.  Such blocks can be augmented by header
arguments that control the way [[latex:proglang][Org-mode]] handles evaluation and export.
#+begin_src org
  ,#+source: <name>
  ,#+begin_src <language> <header arguments>
  ,  <body>
  ,#+end_src
#+end_src

*** Evaluation

When a code block is evaluated, the captured output appears by default
in the [[latex:proglang][Org-mode]] buffer immediately following the code block, e.g.,
#+begin_src org
   ,#+begin_src ruby :exports none
   ,  require 'date'
   ,  "This was last evaluated on #{Date.today}"
   ,#+end_src
   ,
   ,#+results:
   ,: This was last evaluated on 2010-11-01
#+end_src

#+begin_src ruby :exports none
  require 'date'
  "This was last evaluated on #{Date.today}"
#+end_src

By default, a code block is evaluated in a dedicated system process
that does not persist after evaluation is complete. The =:dir= header
argument can be used to specify the directory associated with the
system process; if this is a directory on a remote machine then the
code executes on the remote machine and the results are automatically
transferred across the network to the local Emacs process.

In addition, evaluation of several languages may be performed in an
interactive Emacs "session" that persists indefinitely. For example,
session-based evaluation of R code uses R sessions provided by the
Emacs Speaks Statistics (ESS) project \citep{ess}.  Thus, both the [[latex:proglang][Org-mode]]
buffer and the language-specific session buffers may be used to
share functions and data structures between blocks. In [[latex:proglang][Org-mode]],
[[latex:proglang][R]] code editing and session-based [[latex:proglang][R]] evaluation are implemented using
ESS. Therefore [[latex:proglang][Org-mode]] is not a replacement for ESS; rather [[latex:proglang][Org-mode]]
provides a document authoring and project management environment
within which to embed traditional ESS usage.

Session-based evaluation during export to LaTeX is similar to the approach
taken by [[latex:proglang][Sweave]], in which every code block is evaluated in the same
persistent session.  In [[latex:proglang][Org-mode]], the =:session= header argument takes
an optional name, making it possible to maintain multiple distinct
sessions.  Thus, [[latex:proglang][Org-mode]] builds upon and extends the functionality of [[latex:proglang][Sweave]].
# Shall we be explicit here that Org-mode is a direct competitor of
# Sweave?
# Why not? 

*** Results
[[latex:proglang][Org-mode]] returns the results of code block evaluation as strings,
scalars, tables, or links.  By default, these are
inserted in the [[latex:proglang][Org-mode]] buffer as special plain text elements immediately after
the code block.  In practice, the user has extensive control over how
evaluation results are handled.

At the most basic level, results can be collected from code blocks by
value or as output.  This behavior is controlled by the =:results=
header argument.

- =:results value= :: Specifies that the code block should be treated
     as a function, and the results should be equal to the value of
     the last expression in the block, like the return value of a
     function.  This is the default setting.

- =:results output= :: Specifies that the results should be collected
     from =STDOUT= incrementally, as they are written by the
     application responsible for code execution.

These differences are demonstrated by the following
[[latex:proglang][perl]] code, which yields different results depending
on the value of the =:results= header argument.  Note that the first
example uses the default =:results value= and returns a scalar.  When
output is returned the same code yields a string.

#+begin_src org
  ,#+begin_src perl
  ,  $x = 8;
  ,  $x = $x + 1;
  ,  print "shouting into the dark!\n";
  ,  $x
  ,#+end_src
  
  ,#+results:
  ,: 9
    
  ,#+begin_src perl :results output
  ,$x = 8;
  ,$x = $x + 1;
  ,print "shouting into the dark!\n";
  ,$x
  ,#+end_src
  
  ,#+results:
  ,: shouting into the dark!  
#+end_src org

#+begin_src perl :exports none
  $x = 8;
  $x = $x + 1;
  print "shouting into the dark!\n";
  $x
#+end_src

#+begin_src perl :results output :exports none
$x = 8;
$x = $x + 1;
print "shouting into the dark!\n";
$x
#+end_src

[[latex:proglang][Org-mode]] also recognizes vector and matrix results and
inserts them as tables into the buffer, as demonstrated by the
following two blocks of Haskell code.

#+begin_src org
  ,#+begin_src haskell
  ,  [1, 2, 3, 4, 5]
  ,#+end_src
  
  ,#+results:
  ,| 1 | 2 | 3 | 4 | 5 |
  
  ,#+begin_src haskell
  ,  zip [1..] (map (+1) [1, 2, 3])
  ,#+end_src
  
  ,#+results:
  ,| 1 | 2 |
  ,| 2 | 3 |
  ,| 3 | 4 |
#+end_src

#+begin_src haskell :exports none
  [1, 2, 3, 4, 5]
#+end_src

#+begin_src haskell :exports none
  zip [1..] (map (+1) [1, 2, 3])
#+end_src

When the result of evaluating a code block is a file, the =:file=
header argument can be used to provide a path and
name for the file.  [[latex:proglang][Org-mode]] saves the results to the named file and
places a link to it in the document.  These links are handled by
[[latex:proglang][Org-mode]] in the usual ways; they can be opened from within the document
and included in exports with captions and labels for cross-referencing.

Much more information about controlling the evaluation of code and the
handling of code results is available in the [[latex:proglang][Org-mode]] documentation.[fn:4]

# DONE: provide links to the website/manual/Worg

*** Variables
[[latex:proglang][Org-mode]] implements a simple system of passing arguments to code
blocks.  The =:var= header argument takes a variable name and a value
and assigns the value to the named variable inside the code block.
Values can be literal values, such as scalars or strings, references
to named data blocks, links, or references to named code blocks.
In the latter case, the value is the result of evaluating the
referenced code block.

All values passed to variables are served by the [[latex:proglang][Emacs Lisp]]
interpreter that is at the core of Emacs.  This argument passing
syntax allows for complex chaining of raw values in a document, and
the results of computations in one computer language can be used as
input to blocks of code in another language, as shown in Section
\ref{examples}.

** Export
    :PROPERTIES:
    :CUSTOM_ID: export
    :END:

Borrowing terms from the Literate Programming literature, [[latex:proglang][Org-mode]]
supports both /weaving/---the exportation of a mixed code/prose
document to a prose format suitable for reading by a human---and
/tangling/---the exportation of a mixed code/prose document to a pure
code file suitable for execution by a computer.

- weaving :: [[latex:proglang][Org-mode]] provides a sophisticated and full-featured
     system to export to HTML, LaTeX, and a number of other target
     formats, with support for pre-processing code blocks as part of
     the export process.  Using the =:exports= header argument, the
     code of the code block, the results of executing the code block,
     both code and results, or neither can be included in the export.

- tangling :: Source code in an [[latex:proglang][Org-mode]] document can be re-arranged
     on export.  Often, the order in which a computer needs to be
     presented with code differs from the order in which the code may
     be best organized in a document.  Literate programming systems
     like [[latex:proglang][noweb]] solve this problem using code-block references that
     are expanded as part of the tangle process \citep{noweb}.
     [[latex:proglang][Org-mode]] implements the [[latex:proglang][noweb]] reference system using
     identical syntax and functionality.

** COMMENT Export/Weaving/Tangling terminology
   What is the relationship of these terms? This crops up at the start
   of the next para.

*** Scheme A: Weaving and Tangling are types of export
    - Export
      - Weaving
      - Tangling
*** Scheme B: Weaving and Export are synonyms
   - Export == Weaving
   - Tangling something else
    
** Language support
    :PROPERTIES:
    :CUSTOM_ID: languages
    :END:

The core functions of [[latex:proglang][Org-mode]] related to source code are language
agnostic.  The tangling, source code edit, and export features can be
used for any computer language, even those that are not specifically
supported; only code evaluation and interaction with live sessions
require language-specific functions.  Support for new languages can be
added by defining a small number of [[latex:proglang][Emacs Lisp]] functions named
according to language, following some simple conventions.  Currently,
[[latex:proglang][Org-mode]] has support for more than 30 languages.  The ease with which
support for new languages can be added is evidenced by the fact that
new language support is increasingly implemented by [[latex:proglang][Org-mode]] users.

** Safety considerations
A reproducible research document includes code that
can be evaluated.  This carries the potential of giving a malicious hacker direct
access to the reader's computer.  The primary defense in this instance
is for the reader to recognize malicious code and to choose not to run
it.  This can be a difficult task in a reproducible research document
written in a single computer language, such as one written with
Sweave, but the difficulty increases if the document is written in
several computer languages, one or more of which is not understood by
the reader.

[[latex:proglang][Org-mode]] has been designed with security measures to protect users
from the accidental or uninformed execution of code.  By default
/every/ execution of a code block requires explicit confirmation from
the user.[fn:1]

# I'm tempted to leave the following bit out on the basis that it is
# usage detail rather than high-level [DD]

# In addition, it is possible to remove code block
# evaluation from the default =C-c C-c= key binding.  This key binding
# is ubiquitous in [[latex:proglang][Org-mode]], and is typically bound to the function most
# likely to be called from a particular context.  An alternative key
# binding is present for code block evaluation, namely =C-c C-v e=.  The
# three key strokes required for this binding, and the fact that it is
# not used elsewhere in [[latex:proglang][Org-mode]], provides some degree of protection
# against unintended evaluation of code blocks.

** Where to find information about Org-mode
The official web site for [[latex:proglang][Org-mode]] is maintained by one of us (CD) at
[[http://orgmode.org/]].  The site contains links to the [[http://orgmode.org/index.html#sec-3_1][standard
distribution]], the [[http://orgmode.org/index.html#sec-3_2][development version]], and to [[http://orgmode.org/index.html#sec-3_3][alternative
distributions]] for a variety of operating systems.  Documentation is
available as a book \citep{dominik10:_org_mode_refer_manual} and in a
[[http://orgmode.org/index.html#sec-4_1][variety of formats]] on-line. There is an [[http://orgmode.org/guide/index.html][on-line compact guide]] that can
be downloaded as a 40 page introduction to [[latex:proglang][Org-mode]], a [[http://orgmode.org/orgcard.pdf][reference card]],
a list of[[http://orgmode.org/worg/org-faq.html][ frequently asked questions]], more than 4 dozen [[http://orgmode.org/worg/org-tutorials/index.html][tutorials]], and
a few [[http://orgmode.org/worg/org-tutorials/org-screencasts/index.html][screencasts]].  An active mailing list, emacs-orgmode@gnu.org, has
a [[http://news.gmane.org/gmane.emacs.orgmode][web interface]].

* Examples
   :PROPERTIES:
   :CUSTOM_ID: examples
   :END:

The following section demonstrates with short examples a number of
common [[latex:proglang][Org-mode]] usage patterns.  The first example highlights the flow
of data between tables, code blocks of multiple languages, and
graphical figures.  The second demonstrates the use of traditional
literate programming techniques.  The final example demonstrates the
use of [[latex:proglang][Org-mode]] for data analysis. It involves interaction with
external data sources, automated creation and use of local databases
from within [[latex:proglang][Org-mode]] documents for long-term persistence of
potentially large amounts of data, and the use of session-based
evaluation for short term persistence of smaller data sets.

** Data flow --- Pascal's triangle
   :PROPERTIES:
   :custom_id: pascals-triangle
   :END:

# I think this is a terrific example (TD)
Pascal's triangle is one name for a geometric arrangement of the
binomial coefficients in a triangle.  The triangle has several
interesting and useful mathematical properties.  This example
constructs and manipulates a Pascal's triangle to illustrate potential
data flows in [[latex:proglang][Org-mode]].  Data are passed from a code block to an
[[latex:proglang][Org-mode]] table, from an [[latex:proglang][Org-mode]] table to a code block, from one code
block to another, and from a code block to a graphic figure.  Finally,
the example uses a property of the triangle to test the correctness of
the implementation, using [[latex:proglang][Emacs Lisp]] code blocks embedded in a tabular
view of the triangle to test whether the property is satisfied.

*** Computing Pascal's triangle
The following [[latex:proglang][Python]] source block computes and returns the first
five rows of Pascal's triangle.  [[latex:proglang][Org-mode]] inserts the value returned
by the [[latex:proglang][Python]] function into the [[latex:proglang][Org-mode]] document as a table named
=pascals-triangle=.  This table can be referenced by other code
blocks.
#+begin_src org
   ,#+source: pascals-triangle
   ,#+begin_src python :var n=5 :exports none :return pascals_triangle(5)
   ,  def pascals_triangle(n):
   ,      if n == 0:
   ,          return [[1]]
   ,      prev_triangle = pascals_triangle(n-1)
   ,      prev_row = prev_triangle[n-1]
   ,      this_row = map(sum, zip([0] + prev_row, prev_row + [0]))
   ,      return prev_triangle + [this_row]
   ,#+end_src
   ,
   ,#+results: pascals-triangle
   ,| 1 |   |    |    |   |   |
   ,| 1 | 1 |    |    |   |   |
   ,| 1 | 2 |  1 |    |   |   |
   ,| 1 | 3 |  3 |  1 |   |   |
   ,| 1 | 4 |  6 |  4 | 1 |   |
   ,| 1 | 5 | 10 | 10 | 5 | 1 |
#+end_src

#+source: pascals-triangle
#+begin_src python :var n=5 :exports none :return pascals_triangle(5)
  def pascals_triangle(n):
      if n == 0:
          return [[1]]
      prev_triangle = pascals_triangle(n-1)
      prev_row = prev_triangle[n-1]
      this_row = map(sum, zip([0] + prev_row, prev_row + [0]))
      return prev_triangle + [this_row]
#+end_src

#+results: pascals-triangle
| 1 |   |    |    |   |   |
| 1 | 1 |    |    |   |   |
| 1 | 2 |  1 |    |   |   |
| 1 | 3 |  3 |  1 |   |   |
| 1 | 4 |  6 |  4 | 1 |   |
| 1 | 5 | 10 | 10 | 5 | 1 |

*** Drawing Pascal's triangle
A more pleasing representation of Pascal's triangle can created with the [[latex:proglang][dot]]
graphing language.  In the following code block the =pascals-triangle=
table is passed to a block of [[latex:proglang][Python]] code through the
variable =ps=.  [[latex:proglang][Org-mode]] transforms the table into a [[latex:proglang][Python]] list,
which the [[latex:proglang][Python]] block uses to construct strings of [[latex:proglang][dot]] commands.  The
strings of [[latex:proglang][dot]] commands are intended for use by a subsequent code
block, and not for inclusion into the exported document, as indicated
by the =:exports none= header argument.

#+begin_src org
   ,#+source: ps-to-dot
   ,#+begin_src python :var ps=pascals-triangle :results output :exports none 
   ,  def node(i, j):
   ,        return '"%d_%d"' % (i+1, j+1)
   ,  
   ,  def edge(i1, j1, i2, j2):
   ,        return '%s--%s;' % (node(i1, j1), node(i2,j2))
   ,  
   ,  def node_with_edges(i, j):
   ,        line = '%s [label="%d"];' % (node(i, j), ps[i][j])
   ,        if j > 0:
   ,              line += edge(i-1, j-1, i, j)
   ,        if j < len(ps[i])-1:
   ,              line += edge(i-1, j, i, j)
   ,        return line 
   ,  
   ,  # Eliminate empty table cells
   ,  ps = [filter(None, row) for row in ps]
   ,
   ,  # Output dot commands
   ,  print '\n'.join([node_with_edges(i, j)
   ,                   for i in range(len(ps))
   ,                   for j in range(len(ps[i]))])
   ,#+end_src
#+end_src

#+source: ps-to-dot
#+begin_src python :var ps=pascals-triangle :results output :exports none 
  def node(i, j):
        return '"%d_%d"' % (i+1, j+1)

  def edge(i1, j1, i2, j2):
        return '%s--%s;' % (node(i1, j1), node(i2,j2))

  def node_with_edges(i, j):
        line = '%s [label="%d"];' % (node(i, j), ps[i][j])
        if j > 0:
              line += edge(i-1, j-1, i, j)
        if j < len(ps[i])-1:
              line += edge(i-1, j, i, j)
        return line 
  
  # Eliminate empty table cells
  ps = [filter(None, row) for row in ps]

  # Output dot commands
  print '\n'.join([node_with_edges(i, j)
                   for i in range(len(ps))
                   for j in range(len(ps[i]))])
#+end_src

The output is passed directly into a block of [[latex:proglang][dot]] code by assigning
the name of the [[latex:proglang][Python]] code block to the variable =ps-vals=.  Passing
the results of one code block to another in this way is called
/chaining/; [[latex:proglang][Org-mode]] places no limit on the number of code blocks that
can be chained together.  Evaluation propagates backwards through
chained code blocks.  In this example, the =:file= header argument
causes the code block to save the image resulting from its evaluation
into a file named =pascals-triangle.pdf=, and inserts a link to this
image into the [[latex:proglang][Org-mode]] buffer.  This link will then expand to include
the contents of the image upon export --- it is also possible to view
linked images from within an [[latex:proglang][Org-mode]] buffer.  The link is shown both
in [[latex:proglang][Org-mode]] syntax and in exported form (Figure
\ref{pascals-triangle-fig}).

#+begin_src org
   ,#+source: ps-to-fig
   ,#+headers: :file pascals-triangle.pdf :cmdline -Tpdf
   ,#+begin_src dot :var ps-vals=ps-to-dot :exports results
   ,  graph {
   ,    $ps-vals
   ,  }
   ,#+end_src
   ,
   ,#+Caption: Pascal's Triangle \label{pascals-triangle-fig}
   ,#+ATTR_LaTeX: width=0.5\textwidth
   ,#+results: ps-to-fig
   ,[[file:pascals-triangle.pdf]]
#+end_src
#+LaTeX: %$

#+source: ps-to-fig
#+headers: :file pascals-triangle.pdf :cmdline -Tpdf
#+begin_src dot :var ps-vals=ps-to-dot :exports results
  graph {
    $ps-vals
  }
#+end_src

#+Caption: Pascal's Triangle \label{pascals-triangle-fig}
#+ATTR_LaTeX: width=0.5\textwidth
#+results: ps-to-fig
[[file:pascals-triangle.pdf]]

*** Testing for correctness
Now that Pascal's triangle has been constructed and a graphic
representation prepared, it is worth asking whether the triangle
itself is correct.  Because the sum of successive diagonals of the
triangle yields the Fibonacci series, it is possible to verify that
the triangle is correct.  This can be done in many ways; here, it is
done with a short block of [[latex:proglang][Emacs Lisp]] code that takes a row of numbers
and a number =n= and returns =pass= if the sum of the numbers in the
row is equal the nth Fibonacci number and returns =fail= otherwise.
Calls to this code block can be embedded into the tabular view of
Pascal's triangle using spreadsheet style formulas.  When the
spreadsheet is calculated, it returns =pass= for each of the five
diagonals, confirming that the implementation of Pascal's triangle is
correct.

#+begin_src org
  ,#+source: ps-check
  ,#+begin_src emacs-lisp :var row='(1 2 1) :var n=0 :exports code
  ,  (defun fib (n)
  ,    (if (<= n 2)
  ,        1
  ,      (+ (fib (- n 1)) (fib (- n 2)))))
  , 
  ,  (let ((row (if (listp row) row (list row))))
  ,    (if (= (fib n) (reduce #'+ row))
  ,        "pass"
  ,      "fail"))
  ,#+end_src
  ,
  ,#+results: pascals-triangle
  ,| 0 |    1 |    2 |    3 |    4 |    5 |
  ,|---+------+------+------+------+------|
  ,|   | pass | pass | pass | pass | pass |
  ,| 1 |      |      |      |      |      |
  ,| 1 |    1 |      |      |      |      |
  ,| 1 |    2 |    1 |      |      |      |
  ,| 1 |    3 |    3 |    1 |      |      |
  ,| 1 |    4 |    6 |    4 |    1 |      |
  ,| 1 |    5 |   10 |   10 |    5 |    1 |
  ,#+TBLFM: @2$2='(sbe ps-check (row @3$1)...
#+end_src

#+source: ps-check
#+begin_src emacs-lisp :var row='(1 2 1) :var n=0 :exports none
  (defun fib (n)
    (if (<= n 2)
        1
      (+ (fib (- n 1)) (fib (- n 2)))))
   
  (let ((row (if (listp row) row (list row))))
    (if (= (fib n) (reduce #'+ row))
        "pass"
      "fail"))
#+end_src

** Literate programming --- cocktail sort
Cocktail Sort[fn:2] is a variation of Bubble Sort in which the
direction of array traversal is alternated with each pass.  As a
result Cocktail Sort is more efficient than Bubble Sort for arrays
with small elements located at the end of the array.

The following example produces a command line executable, =cocktail=,
that will print its arguments in sorted order.  The =cocktail.c= code
block uses standard literate programming syntax
(i.e.
#+begin_LaTeX
  \verb=<<block-name>>=
#+end_LaTeX
) to combine the three parts of the
program: the standard C header for input/output; the implementation of
the cocktail sort algorithm; and the command-line mechanism to accept
input and return results.

#+begin_src org :noweb tangle
  ,#+source: cocktail.c
  ,#+begin_src C :noweb tangle :tangle cocktail.c
  ,  #include <stdio.h>
  ,  <<cocktail-sort>>
  ,  <<main>>
  ,#+end_src
#+end_src

#+source: cocktail.c
#+begin_src C :noweb tangle :tangle cocktail.c yes :exports none
  #include <stdio.h>
  <<cocktail-sort>>
  <<main>>
#+end_src

A standard C language =main= method is used to collect command line
arguments, call the sorting algorithm on the supplied arguments, and
print the results.
# DONE: Need to indicate what the arguments to main are about  TD

#+begin_src org
  ,#+source: main
  ,#+begin_src C
  ,  int main(int argc, char *argv[]) {
  ,    int lst[argc-1];
  ,    int i;
  ,    for(i=1;i<argc;i++)
  ,      lst[i-1] = atoi(argv[i]);
  ,    sort(lst, argc-1);
  ,    for(i=1;i<argc;i++)
  ,      printf("%d ", lst[i-1]);
  ,    printf("\n");
  ,  }
  ,#+end_src
#+end_src

#+source: main
#+begin_src C :exports none
  int main(int argc, char *argv[]) {
    int lst[argc-1];
    int i;
    for(i=1;i<argc;i++)
      lst[i-1] = atoi(argv[i]);
    sort(lst, argc-1);
    for(i=1;i<argc;i++)
      printf("%d\n", lst[i-1]);
    return 0;
  }
#+end_src

In the implementation of Cocktail Sort the array is repeatedly
traversed in alternating directions, swapping out-of-order elements.
The actual swapping of elements is handled by =swap=, which sets the
=swapped= flag when it swaps elements, but leaves the flag alone if
the elements are already in sorted order.  This process continues
until no more swaps have been made and the array is sorted.

#+begin_src org
  ,#+source: cocktail-sort
  ,#+begin_src C :noweb tangle
  ,  void sort(int *a, unsigned int l)
  ,  {
  ,    int swapped = 0;
  ,    int i;
  ,  
  ,    do {
  ,      for(i=0; i < (l-1); i++) {
  ,        <<swap>>
  ,      }
  ,      if ( swapped == 0 ) break;
  ,      swapped = 0;
  ,      for(i= l - 2; i >= 0; i--) {
  ,        <<swap>>
  ,      }
  ,    } while(swapped > 0);
  ,  }  
  ,#+end_src
#+end_src

#+source: cocktail-sort
#+begin_src C :noweb tangle :exports none
  void sort(int *a, unsigned int l)
  {
    int swapped = 0;
    int i;
  
    do {
      for(i=0; i < (l-1); i++) {
        <<swap>>
      }
      if ( swapped == 0 ) break;
      swapped = 0;
      for(i= l - 2; i >= 0; i--) {
        <<swap>>
      }
    } while(swapped > 0);
  }  
#+end_src

The =swap= method performs conditional swapping of adjacent array
elements that are not in sorted order.  It sets the =swapped= flag if
it performs a swap.

#+begin_src org
  ,#+source: swap
  ,#+begin_src C
  ,  if ( a[i] > a[i+1] ) {
  ,    int temp = a[i];
  ,    a[i] = a[i+1];
  ,    a[i+1] = temp;
  ,    swapped = 1;
  ,  }
  ,#+end_src
#+end_src

#+source: swap
#+begin_src C :exports none
  if ( a[i] > a[i+1] ) {
    int temp = a[i];
    a[i] = a[i+1];
    a[i+1] = temp;
    swapped = 1;
  }
#+end_src

In usual literate programming practice these parts can be tangled out
to the file =cocktail.c=, as indicated by the =:tangle= header
argument of the =cocktail.c= code block.  Alternately the expanded
code block can be compiled and evaluated from within the Org-mode file
using the following =#+call= line.

#+begin_src org
  ,#+call: cocktail.c[:cmdline 8 7 6 3 2 4 78]()
  ,
  ,#+results: cocktail.c[:cmdline 8 7 6 3 2 4 78]()
  ,: 2
  ,: 3
  ,: 4
  ,: 6
  ,: 7
  ,: 8
  ,: 78
#+end_src

#+call: cocktail.c[:cmdline 8 7 6 3 2 4 78]() :exports none

** Reproducible research --- live climate data
By referencing external data, a work of Reproducible Research can
remain up-to-date long after its initial composition and publication.
This example demonstrates the ability of code blocks in an [[latex:proglang][Org-mode]]
document to reference external data, to construct and use local stores
of data outside the document, and to maintain persistent state in
external sessions, all in an automated fashion. This allows each
reader to recreate the document with up-to-date data, and to
populate a full local workspace with the data used in the document.

This example references climate change data from the US National
Oceanic and Atmospheric Administration (NOAA). The data set is much
larger (hundreds of thousands of rows) than the Pascal's Triangle
example above (Section \ref{pascals-triangle}). Accordingly, this
example demonstrates a different style of working with executable code
blocks in [[latex:proglang][Org-mode]]: instead of transferring large amounts of data
between blocks via [[latex:proglang][Org-mode]] tables and [[latex:proglang][Emacs Lisp]], we use temporary
plain text files on disk and a dedicated external database. The
example is implemented with command-line tools commonly available on
Unix-like systems, the [[latex:proglang][sqlite]] database, and [[latex:proglang][R]].  These software tools
were chosen to illustrate the use of popular data processing tools
from within [[latex:proglang][Org-mode]].  It is worth pointing out, however, that at each
step of the way alternatives exist, one or more of which might
substantially simplify the example for any particular user.

The first two code blocks fetch and parse data from NOAA using
standard command-line tools.

# For raw data format see ftp://ftp.ncdc.noaa.gov/pub/data/ghcn/v2/v2.temperature.readme

#+begin_src org
   ,#+source: raw-temps
   ,#+headers: :file raw-temps.csv :var file="raw-temps.csv" 
   ,#+begin_src sh :exports results
   ,  curl ftp://ftp.ncdc.noaa.gov/pub/data/ghcn/v2/v2.mean_adj.Z \
   ,      |gunzip \
   ,      |perl -pe 's/-9999/ NA/g' \
   ,      |perl -pe 's/^([0-9]{3})([0-9]{8})([0-9])/$1 $2 $3 /' \
   ,      |perl -pe 's/ +/,/g' \
   ,      >$file
   ,#+end_src
   ,
   ,#+source: country-codes
   ,#+headers: :file country-codes.csv :var file="country-codes.csv" 
   ,#+begin_src sh :exports results
   ,  curl ftp://ftp.ncdc.noaa.gov/pub/data/ghcn/v2/v2.slp.country.codes \
   ,      |perl -pe 's/ *$//' \
   ,      |perl -pe 's/ +/,/' \
   ,      >$file
   ,#+end_src
#+end_src
 
#+source: raw-temps
#+headers: :file raw-temps.csv :var file="raw-temps.csv" 
#+begin_src sh :exports none
  curl ftp://ftp.ncdc.noaa.gov/pub/data/ghcn/v2/v2.mean_adj.Z \
      |gunzip \
      |perl -pe 's/-9999/ NA/g' \
      |perl -pe 's/^([0-9]{3})([0-9]{8})([0-9])/$1 $2 $3 /' \
      |perl -pe 's/ +/,/g' \
      >$file
#+end_src

#+source: country-codes
#+headers: :file country-codes.csv :var file="country-codes.csv" 
#+begin_src sh :exports none
  curl ftp://ftp.ncdc.noaa.gov/pub/data/ghcn/v2/v2.slp.country.codes \
      |perl -pe 's/ *$//' \
      |perl -pe 's/ +/,/' \
      >$file
#+end_src

Next, the output of the first two blocks is used to create a local
database of the combined climate data.  In the case of very large data
sets it may be preferable to use an external store like a database
rather than storing the data as plain text in the [[latex:proglang][Org-mode]] buffer.

#+begin_src org
   ,#+begin_src sqlite :db climate.sqlite
   ,  create table temps (country,station,replicate,year,jan,feb,
   ,         mar,apr,may,jun,jul,aug,sep,oct,nov,dec);
   ,  create table countries (code, name);
   ,  .separator ","
   ,  .import raw-temps.csv temps
   ,  .import country-codes.csv countries
   ,#+end_src
#+end_src

#+headers: :var raw-temps-file=raw-temps :var country-codes-file=country-codes
#+begin_src sqlite :db climate.sqlite :exports none :results silent
  drop table if exists temps;
  create table temps (country,station,replicate,year,jan,feb,
         mar,apr,may,jun,jul,aug,sep,oct,nov,dec);
  drop table if exists countries;
  create table countries (code, name);
  .separator ","
  .import $raw-temps-file temps
  .import $country-codes-file countries
#+end_src

The =get-temps= code block reads a subset of the data from the sqlite
database, and then the =R-init= code block splits the data into a
separate time series for each weather station, in an ESS R
session named =*R-climate*=. The variables persist in the
=*R-climate*= session after the code block exits, so they can be
manipulated by other R code blocks that use the =*R-climate*= session.

#+begin_src org
   ,#+source: R-init
   ,#+headers: :var dbname="climate.sqlite"
   ,#+begin_src R :session *R-climate*
   ,  library("RSQLite")
   ,  con <- dbConnect(dbDriver("SQLite"), dbname=dbname)
   ,  query <- paste("SELECT temps.station, temps.year, temps.jul FROM temps, countries",
   ,                 "WHERE countries.code=temps.country",
   ,                 "AND countries.name='UNITED STATES OF AMERICA'",
   ,                 "AND temps.replicate='0'",
   ,                 "ORDER BY year;")
   ,  temps <- dbGetQuery(con, query)
   ,  temps$year <- as.integer(temps$year)
   ,  temps$jul <- as.numeric(temps$jul)/10
   ,  temps.by.station <- split(temps, temps$station, drop=TRUE)
   ,#+end_src
#+end_src

#+source: R-init
#+headers: :var dbname="climate.sqlite"
#+begin_src R :session *R-climate* :exports results :results silent
  library("RSQLite")
  con <- dbConnect(dbDriver("SQLite"), dbname=dbname)
  query <- paste("SELECT temps.station, temps.year, temps.jul FROM temps, countries",
                 "WHERE countries.code=temps.country",
                 "AND countries.name='UNITED STATES OF AMERICA'",
                 "AND temps.replicate='0'",
                 "ORDER BY year;")
  temps <- dbGetQuery(con, query)
  temps$year <- as.integer(temps$year)
  temps$jul <- as.numeric(temps$jul)/10
  temps.by.station <- split(temps, temps$station, drop=TRUE)
#+end_src

Finally the persistent variables in the =*R-climate*= session are used
to generate figures from the climate data. Here we fit a straight line
to the July temperatures at each station which has measurements
spanning the period 1880-1980, and plot a histogram of the fitted
slope parameters. The figure is written to a pdf file for
incorporation into the exported document (Figure
\ref{fig:climate-trend}).

#+begin_src org
   ,#+srcname: R-graph
   ,#+begin_src R :session *R-climate* :file temp-trends.pdf :exports results
   ,  include.station <- function(station)
   ,      station$year[1] <= 1880 && station$year[nrow(station)] >= 1980
   ,  fit.slope <- function(station)
   ,      with(station, coefficients(lm(jul ~ year))["year"])
   ,  included <- sapply(temps.by.station, include.station)
   ,  slopes <- sapply(temps.by.station[included], fit.slope)
   ,  hist(slopes)
   ,#+end_src
   ,
   ,#+Caption: Temperature trends between 1880 and the present at weather stations in the USA \label{fig:climate-trend}
   ,#+ATTR_LaTeX: width=0.7\textwidth
   ,#+results: R-graph
   ,[[file:temp-trends.pdf]]
#+end_src

#+srcname: R-graph
#+begin_src R :session *R-climate* :file temp-trends.pdf :exports results
  include.station <- function(station)
      station$year[1] <= 1880 && station$year[nrow(station)] >= 1980
  fit.slope <- function(station)
      with(station, coefficients(lm(jul ~ year))["year"])
  included <- sapply(temps.by.station, include.station)
  slopes <- sapply(temps.by.station[included], fit.slope)
  hist(slopes)
#+end_src

#+Caption: Temperature trends between 1880 and the present at weather stations in the USA. \label{fig:climate-trend}
#+ATTR_LaTeX: width=0.7\textwidth
#+results: R-graph
[[file:temp-trends.pdf]]

* Discussion
  :PROPERTIES:
  :CUSTOM_ID: discussion
  :END:

[[latex:proglang][Org-mode]] has several features that make it a potentially useful tool
for a community of researchers and developers.  These include:

- Open source :: [[latex:proglang][Org-mode]] is open source software.  Its inner
     workings are publicly visible, and its copyright is owned by the
     Free Software Foundation \citep{fsf}.  This ensures that
     [[latex:proglang][Org-mode]] and any work deriving from [[latex:proglang][Org-mode]] will always be
     fully open to public scrutiny and modification.  These are
     essential qualities for software tools used for reproducible
     research.  The transparency required for computational results to
     be accepted by the scientific community can only be achieved when
     the workings of each tool in the scientist's tool chain is open to
     inspection and verification.

- Widely available :: Software used in reproducible research should be
     readily available and easily installed by readers.  [[latex:proglang][Org-mode]] is
     freely available and, as of the next major release of Emacs
     (version 24), [[latex:proglang][Org-mode]] including all of the facilities discussed
     herein will be included in the Emacs core.  Emacs is one of the
     most widely ported software applications, making possible the
     installation and use of [[latex:proglang][Org-mode]] on a wide
     variety of user systems.

- Active community :: The [[latex:proglang][Org-mode]] community
     provides ready support to both novice users with basic questions
     and to developers seeking to extend [[latex:proglang][Org-mode]].
     The development of [[latex:proglang][Org-mode]] would not have
     been possible without the attention and effort of this community.

- General and extensible :: A main design goal of [[latex:proglang][Org-mode]]'s support
     for working with source code was pursuit of generality.  As a
     result, it displays no reproducible research or literate
     programming bias, supports arbitrary programming languages, and
     exports to a wide variety of file types, including ASCII, LaTeX,
     HTML, and DocBook.  Researchers and software developers who adopt
     [[latex:proglang][Org-mode]] can be confident that it will be able to adapt to new
     languages or modes of development.

- Integration :: [[latex:proglang][Org-mode]] leverages the sophisticated editing modes
     available in Emacs for both natural and computational languages.


Literate programming and reproducible research systems are typically
prescriptive and difficult to use, and this cost of adoption has kept
them from spreading more widely through the computing community.
[[latex:proglang][Org-mode]] makes it possible to practice literate programming and
reproducible research in a plain text editing environment,
thereby lowering the adoption cost of these techniques.  [[latex:proglang][Org-mode]] is
designed so that all stages of the research and development cycle can
be captured in a single document.  This design feature makes it
possible to collocate all the code, data, and text relevant to a
project, eliminating or reducing the burden of assembling dispersed
files of code and text at the project's end.  We believe that with its
ease of adoption, familiar environment, and universal applicability
across programming languages, [[latex:proglang][Org-mode]] represents
an advance in literate programming and reproducible research tools.

We also believe that [[latex:proglang][Org-mode]] has the potential to advance the
expectation that all computational projects include /both/ code and
prose; the arguments that Knuth advanced for literate programming are
no less valid today, and the rise of electronic publishing has created
new opportunities for distributing reproducible research.  [[latex:proglang][Org-mode]]
provides researchers and software developers with a powerful tool to
communicate their work and make it more accessible.

# "Meteoric rise" is unfortunate
# And has now suffered the fate of most meteors.

#+begin_LaTeX
    \bibliography{babel,babel2,jstatsoft}
#+end_LaTeX

** COMMENT Conclusion
# I'm commenting this out for now, I've included one of the points
# above, perhaps some other parts of this discussion should be
# included in the conclusion, but for now I feel that the shorter
# conclusion above may be sufficient -- Eric

[[latex:proglang][Org-mode]] simultaneously satisfies the software requirements of
reproducible research and literate programming; it is in effect both a
/compendium/ and a /web/.  The [[latex:proglang][Org-mode]] environment, used in
combination with a suitable version control tool, satisfies the
requirements for authoring, auxiliary, transformation, quality control
and distribution software set out by Gentleman and Temple Lang in
their formulation of a compendium.  In addition, [[latex:proglang][Org-mode]] already
accomplishes three of the four goals of their "future work", namely
support for /multiple languages/, /conditional chunks/ (where "chunks"
are blocks of text or code), and /interactivity/, which refers to
[[latex:proglang][Org-mode]]'s ability to execute code from within the authoring
environment.

What is the fourth goal that [[latex:proglang][Org-mode]] doesn't accomplish?  Here it is:

#+begin_quote
    Metadata Inclusion of programmatically accessible meta-information
    in documents facilitates both richer interactions and better
    descriptions of the content. Many scientific documents contain
    keywords as part of the text. Making these explicitly available
    to cataloging and indexing software as programmatically
    extractable elements of the dynamic document will facilitate
    richer distribution services. Since dynamic documents are
    software, licensing also becomes pertinent. One may wish to
    restrict evaluation or access to data within the compendium. This
    can be done with meta-information such as license key matching or
    explicit code within the document to verify authorization. Another
    use of meta-information is the inclusion of digital signatures
    which can be used to verify the origin and legitimacy of the
    compendium.
#+end_quote

I probably don't understand this fully, but it seems to me that it
would be possible to provide "programmatically accessible
meta-information."  I implemented a simple OAI interface to my web
site many years ago--that mostly involved understanding the metadata
structure known as the Dublin core used by librarians.  TD

[[latex:proglang][Org-mode]] is a full featured /web/ tool.  It supports both /tangling/
and /weaving/ of code, as well as a sophisticated code block reference
system along the lines of [[latex:proglang][noweb]].  Additionally the executability of
code blocks in [[latex:proglang][Org-mode]] allows for interactive development, and
integration of test suites in a manner not supported in previous
literate programming systems.

Because [[latex:proglang][Org-mode]] is distributed with Emacs, it is installed on very
many computer systems and is widely used.  The [[latex:proglang][Org-mode]] mailing list
has more than 1,400 subscribers, and the list receives several dozen
messages a day.  Although [[latex:proglang][Org-mode]] is being actively developed, its
core functions are mature and stable.  [[latex:proglang][Org-mode]] users rely on it in
production situations in diverse applications such as time tracking,
project planning, research note-taking, programming, systems
management, web site creation, technical documentation, presentation
graphics, data analysis, and manuscript preparation for publication.
A comprehensive user manual and various shorter summary documents
are available in formats for print, computer terminal, and web
browser.  The official web site, [[http://orgmode.org/]], is supplemented
by Worg ([[http://orgmode.org/worg/]]), where users jointly edit and
maintain documentation about [[latex:proglang][Org-mode]] including the Org-mod FAQ and a
wide variety of tutorials.  The literate programming and reproducible
research facilities of [[latex:proglang][Org-mode]] have their own section of Worg with
information on supported languages, examples of common use scenarios,
current developments.

Perhaps here we should discuss the kinds of projects that [[latex:proglang][Org-mode]] has
been used to accomplish instead of the following two paragraphs?  I'm
a bit concerned that "ease of use" contradicts the "complex
configuration" problems discussed above.  TD

** COMMENT Directions for future development
   :PROPERTIES:
   :CUSTOM_ID: future-work
   :END:

# This sections doesn't seem to add to the paper, thoughts? -- Eric

There are a number of avenues for further development of [[latex:proglang][Org-mode]], or
for a future tool of this type.

- editor agnostic :: These  was developed within the rich framework
     of Emacs and [[latex:proglang][Org-mode]], which made the idea of Babel possible in
     the first place.  Now that Babel is developed, however, the tie
     to a single editing environment, even one as completely
     configurable as Emacs, means that Babel is less general than it
     might be.  It seems that it would be possible for future tools of
     this nature to provide code evaluation and exportation as a
     service which could be called from any number of editors.  Such a
     structure would raise a number of challenging implementation
     issues.

- virtual machine :: [[latex:proglang][Org-mode]] allows heterogeneous programming
     environments to share data by dropping all shared values to the
     common denominator of [[latex:proglang][Emacs Lisp]].  This works well for [[latex:proglang][Org-mode]]
     as it allows for re-use of many pre-existing Emacs tools for
     evaluation of code in a variety of languages, often making the
     addition of support for new languages trivial.  There are however
     properties of [[latex:proglang][Emacs Lisp]] which make it less than ideal as a
     medium of data exchange and as a shepherd of evaluation.  Most
     importantly the [[latex:proglang][Emacs Lisp]] interpreter is /single threaded/,
     which makes the asynchronous evaluation of code blocks needlessly
     complex (in fact this feature does not yet exist in [[latex:proglang][Org-mode]]).

This leaves dangling the question of whether and why asynchronous
evaluation is useful.  TD

* Acknowledgments
  The following friends and colleagues kindly read and offered
  comments on drafts of the paper: Erik Iverson, Eric S. Fraga, Bill
  White, Nick Dokos, Detlef Steuer, Konrad Hinsen, Christopher Allan
  Webber, Charles C. Berry, Sebastien Vauban.
  - Org-mode mailing list
  - Counsyl (ES and DD)
* COMMENT Tasks
** TODO Header args
   If we're going to change header arg semantics a little in babel
   (making :output :results and :file more coherent, Eric and I have
   mentioned this at some point recently) then let's try to make sure
   that blocks in the paper use any new form. E.g. the R block may
   become

   :output file :file temp-trends.pdf

(in which case an explicit return of the file name as a character string
would be required?)

   or

   :output graphics :file temp-trends.pdf
** TODO Lightweight execution pathway?
   Should the org document have some sort of flag enabling a lightweight
   execution path that avoids long downloads of data?
** TODO Terminological consistency
   This may be fine as-is, bu for the record:
*** "Computational" versus "computer" languages
*** "Prose" versus "natural language"
** TODO Get rid of \texttt{SCHEDULED} appearing in pdf
** TODO Store file names in variables/blocks
   In the climate example there is some redundancy in that lines like e.g.

#+headers: :file country-codes.csv :var file="country-codes.csv" 

seem suboptimal. Can we store these paths in results blocks / elisp variables?

** TODO How to obtain Org-mode?
   Are we going to make any statements regarding inclusion of recent
   Orgs Org in recent Emacs versions and/or obtaining Org from the
   website/git/elpa?
** TODO include Author information
The following looks like little much on the title page, I guess leave
this until there's an actual template for us to use.
#+begin_src latex
  \author{Eric Schulte\\
  \small Department of Computer Science\\
  \small University of New Mexico\\
  \small 1 University of New Mexico\\
  \small Albuquerque, NM 87131\\
  \small United States of America\\
  \small E-mail: eschulte@cs.unm.edu
  \and
  Dan Davison\\
  \small Mathematical Genetics and Bioinformatics Group\\
  \small Department of Statistics\\
  \small University of Oxford\\
  \small 1 South Parks Road\\
  \small Oxford OX1 3TG\\
  \small United Kingdom\\
  \small E-mail: dandavison7@gmail.com
  \and
  Carsten Dominik\\
  \small Sterrenkundig Instituut "Anton Pannekoek"\\
  \small University of Amsterdam,\\
  \small Science Park 904\\
  \small 1098 XH Amsterdam\\
  \small The Netherlands\\
  \small Department of Astrophysics\\
  \small Radboud University Nijmegen, P.O. Box\\
  \small 9010, NL-6500 GL Nijmegen\\
  \small The Netherlands\\
  \small E-mail: dominik@uva.nl
  \and
  Thomas S. Dye\\
  \small T. S. Dye \& Colleagues, Archaeologists, Inc.\\
  \small 735 Bishop St., Suite 315\\
  \small Honolulu, HI 96813\\
  \small United States of America\\
  \small E-mail: tsd@tsdye.com
  }
#+end_src

** STARTED URL for Org source of the document
The document (and anything else needed to recreate the pdf) should be
made available on the web, and the URL should be published in the
paper.
** TODO Org source URL footnote not exporting correctly
** DONE Implement R examples in RR example
** TODO What are the correct header args for the src blocks?
   We have "active" src blocks, and inactive copies for export
   protected within org blocks Do we have the right combination
   of :results and :exports header args in those two sets of blocks?
** CANCELLED Is this indexing correct?
#+headers: :var countries=country-codes[1:-1,0:1]

* COMMENT Conflicts with JSS style
#+begin_latex
  \lstdefinelanguage{org}
  {
    morekeywords={:results, :session, :var, :noweb, :exports},
    sensitive=false,
    morecomment=[l]{\#},
    morestring=[b]",
  }
  \lstdefinelanguage{dot}
  {
    morekeywords={graph},
    sensitive=false,
  }
  \hypersetup{
    linkcolor=blue,
    pdfborder={0 0 0 0}
  }
  \renewcommand\t[1]{{\tt #1}}
  \newcommand\ATCES{{\sf atce/r}}
  \newcommand\lt[1]{{\lstinline+#1+}}
  \definecolor{dkgreen}{rgb}{0,0.5,0}
  \definecolor{dkred}{rgb}{0.5,0,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \lstset{basicstyle=\ttfamily\bfseries\scriptsize,
    morekeywords={virtualinvoke,fucompp,fnstsw,fldl,fstpl,movl},
    keywordstyle=\color{blue},
    ndkeywordstyle=\color{red},
    commentstyle=\color{dkred},
    stringstyle=\color{dkgreen},
    numbers=left,
    numberstyle=\ttfamily\footnotesize\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{white},
    tabsize=4,
    showspaces=false,
    showstringspaces=false,
    xleftmargin=.23in
  }
#+end_latex

* Footnotes

[fn:1] These confirmation requests can be stifled by customizing the
=org-confirm-babel-evaluate= variable.

[fn:2] This implementation of Cocktail Sort is adapted from
http://rosettacode.org/.

[fn:3] David Gillespie 1990,
http://www.gnu.org/software/emacs/calc.html.

[fn:4] http://orgmode.org/manual/Working-With-Source-Code.html.

[fn:5] https://github.com/eschulte/babel-dev/raw/master/paper/babel.org
* COMMENT Org-mode list comments
** [1/6] Erik Iverson
   - [ ] anything you can add in the intro to give the uninitiated
         reader ideas about how versatile and organic Org-mode is would be
         beneficial!
   - [ ] Figure 1: Consider changing 'export' to 'Weave', as that is the language
         used to reference this action in section 3.3 of the manuscript.
         There are also commas before the headlines in Org-mode bubble,
         I don't know what purpose those serve.
   - [X] p. 6 becasue
   - [ ] Section 3.1.3, perhaps mention that Org-mode provides table
         editing commands to construct tables easily.
   - [ ] Section 3.2, I would suggest reordering things slightly.
     - Clearly, the main concept of interest here is that of
       the code block.  I think these should be introduced
       immediately in section 3.2.1, so that the reader understands
       that this is the primary machine to make things happen.
     - So, section 3.2.1 might start off with code block syntax,
       followed by a section on data blocks.  I would also say
       a sentence or two about the syntax of a source code block.
     - Even though the 4 line skeleton seems natural to us, if
       we imagine that we haven't seen it before, it might help
       to have some English text to describe the important
       information it can contain.
   - [ ] Section 3.2.2, I would say, "the captured output appears by default in a results block
         in the Org-mode buffer..."
   - [ ] Section 3.2.3, Although it is mentioned later, you might
         briefly mention at the end of this section, that graphical content can be
         viewed in the Org-mode buffer itself, making Org-mode an
         'interactive notebook' of sorts.
   - [ ] Section 3.3, weaving: "export to HTML an number", fix typo
     [td can't find this]
   - [ ] I might also add a sentence describing what this means in
         practice.  That is, that you have a 'write once' org-mode document
         with prose/code, and with one batch command, you can export to
         multiple (PDF, HTML, ...) file formats, hiding from your readers
         the code that was used to generate the numbers and figures in the
         outputs.  When the analyses change, you only have to update one
         source document, re-export, and all the targets are updated.
   - [ ] Section 3.5, I might say "document reader's computer" for
         clarity
   - [ ] End of section 4.2, You may want to say 1 sentence about what
     the #+call line is doing, since that syntax does not appear elsewhere.

** [0/2] Eric S. Fraga
   - [ ]  [[http://www.springer.com/computer/journal/11086][Programming and Computer Software]] 
   - [ ]  [[http://www.computer.org/portal/web/tse/][IEEE Transactions on Software Engineering]]

** [3/6] Bill White
   - [X] becasue
   - [ ] Gentleman and Temple Lang, pg. 7
   - [ ] \texttt in source block
   - [X] Org-mode constructs -> Org-mode results blocks
   - [ ] get-temps code block referenced but doesn't appear
   - [X] an wide variety
   - [ ] 

** [2/5] Nick Dokos
   - [ ] \texttt in source block
   - [X] #+ATT -> #+ATTR_LATEX in code block ps-to-fig [OK in this
     file, td]
   - [X] propagate -> populate? Yes, td
   - [ ] sqlite code block: it does not have a #+source attribute
         (should it?) and the quoted code is out of sync with the  "real"
         code, missing the "drop table" construct and some header args.  I
         take it there is no concept of radio-code that would populate the
         ``#+begin_src org'' block with an up-to-date copy of the real code,
         is  there?
   - [ ] missing get-temps code block, pg. 23, sec. 5
  
Finally, the questions: in Sec. 4.1.3, I may be missing something
fundamental, but I don't understand how that works at all. In
particular, is the table formula complete as it stands? How does it get
the diagonals? How are these things passed to the code block? Why does
the code block have values given to the variables? Is it correct as it
stands, or are things missing? This is the one section where I was
completely lost.  Could somebody explain?

** [1/3] Detlef Steuer
   - [ ] Thinks article should have more statistics for JSS
   - [X] Wants more focus on compendium [I think we're OK here.  After
     all, the paper itself will be made available as a compendium.  TD]
   - [ ] stress "always-correctness" of graphs [I don't know what he
     means here, td]

** [0/2] Konrad Hinsen
   - [ ] [[http://cise.aip.org/][Computing in Science and Engineering]]
   - [ ] Short version of article for "Scientific Programming"
     department of Computing in Science and Engineering.
** [0/1] Christopher Allan Webber
   - [ ] Fig. 1 source block is C, not sh
** [0/1] Charles C. Berry
   - [ ] [[http://journal.r-project.org/][The R Journal]]  [I believe this journal is too R specific, td]
** [0/10] S. Vauban
   - [ ] Add "data" to "desirable to mix prose, code, and
     computational results."  pg. 1
   - [ ] No commas in front of the Org-mode block in Fig. 1
   - [ ] Properties of a node inherited by sub-nodes?  pg. 9
   - [ ] Change "active code block" to "named code block" to bring
     paper in alignment with code base
   - [ ] Delete "incrementally" from "collected from STDOUT
     incrementally" pg. 12
   - [ ] Change code block name from ps-to-dot to somethat that
     doesn't make SV think of postscript
   - [ ] Use linewidth instead of textwidth in the LaTeX_ATTR: pg. 17
   - [ ] Is var(1 2 1) compliant with "pass" table?
   - [ ] Handle acronyms in a standard way and list them at end [This
     is something that I can do relatively easily if it appeals, td]
   - [ ] Not good for publishing in statistics journal, should go to
     "another audience."
* COMMENT JSS Review
** TODO References are on the thin side
   :LOGBOOK:
   - State "STARTED"    from ""           [2011-05-22 Sun 14:53]
   :END:
*** The Org Mode 7 Reference Manual: Organize Your Life with GNU Emacs
    :PROPERTIES:
    :TITLE:    The Org Mode 7 Reference Manual: Organize Your Life with GNU Emacs
    :TYPE:     book
    :AUTHOR:   Carsten Dominik
    :PUBLISHER: Network Theory
    :YEAR:     2010
    :ADDRESS:  UK
    :NOTE:     with contributions by David O`Toole, Bastien Guerry, Philip Rooke, Dan Davison, Eric Schulte, and Thomas Dye
    :CUSTOM_ID: dominik10:_org_mode_refer_manual
    :END:
*** StatWeave User's Manual
    :PROPERTIES:
    :TITLE:    StatWeave User's Manual
    :TYPE:     manual
    :AUTHOR:   Russell V. Lenth
    :ORGANIZATION: University of Iowa
    :URL: http://www.stat.uiowa.edu/~rlenth/StatWeave/StatWeave-manual.pdf
    :MONTH:    Feb
    :YEAR:     2009
    :NOTE:     Accessed May 22, 2011
    :CUSTOM_ID: lenth09:_statw_users_manual
    :END:
*** The OdfWeave Package
    :PROPERTIES:
    :TITLE:    The OdfWeave Package
    :TYPE:     manual
    :AUTHOR:   Max Kuhn
    :ORGANIZATION: R Project
    :MONTH:    Dec
    :URL: http://cran.r-project.org/web/packages/odfWeave/vignettes/odfWeave.pdf
    :YEAR:     2010
    :NOTE:     Accessed May 22, 2011
    :CUSTOM_ID: kuhn10:_odfweav_packag
    :END:
*** Excel :: COM :: R
    :PROPERTIES:
    :TITLE:    Excel :: COM :: R
    :TYPE:     article
    :AUTHOR:   Thomas Baier and Erich Neuwirth
    :JOURNAL:  Computational Statistics
    :YEAR:     2007
    :VOLUME:   22
    :NUMBER:   1
    :PAGES:    91--108
    :MONTH:    April
    :CUSTOM_ID: baier07:_excel
    :END:
** DONE Need to refer to documentation
   :LOGBOOK:
   - State "DONE"       from ""           [2011-05-22 Sun 14:51]
   :END:
  TD added the heading [[Where%20to%20find%20information%20about%20Org-mode][Where to find information about Org-mode]]

