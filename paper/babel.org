#+TITLE: Babel /DRAFT/
#+AUTHOR: 
#+OPTIONS: ^:nil toc:nil
#+STARTUP: oddeven hideblocks
#+STYLE: <link rel="stylesheet" href="http://cs.unm.edu/~eschulte/classes/emacs.css" type="text/css"/>  
#+LATEX_HEADER: \usepackage{attrib}
#+LaTeX_CLASS: twocolumn
#+begin_latex
\definecolor{strings}{RGB}{60,179,113}
\lstset{
  keywordstyle=\color{blue},
  commentstyle=\color{red},
  stringstyle=\color{strings}
}
\hypersetup{
  linkcolor=blue,
  pdfborder={0 0 0 0}
}
#+end_latex

#+LaTeX: \begin{abstract}
We present a new computing environment for the authoring of mixed
natural and computer language documents. In this environment a single
hierarchically-organized plain text source file may contain a variety
of elements such as source code in a variety of programming languages,
raw data, links to external resources, project management data,
working notes, and text for publication. Source code fragments may be
executed in situ with graphical and text output captured in, or linked
to from, the source file. Export to LaTeX, HTML, Beamer and other
formats permits working reports, presentations and manuscripts for
publication to be generated from the source file. In addition, source
code extraction (tangling) permits functioning pure code files to be
extracted from the file. This framework is implemented as an extension
to the Emacs text editor and provides a very rich set of features for
working with the source file, including natural environments for
authoring both prose and code, as well as sophisticated project
management capabilities.
#+LaTeX: \end{abstract}

* Introduction
There are a variety of setting in which it is desirable to mix prose
and code in a single container.
- /Scientific research/ increasingly involves the use of computational
  tools the inclusion of which is vital to successful communication
  and verification of research results.
- In /software development/ the exchange of ideas is accomplished
  through both shared code and prose, with the former providing for
  concrete succinct description, and the later providing higher level
  explanation.  Without proper documentation the usability and future
  extensibility of computational tools is severely compromised.
- In /pedagogical/ environments it is important for descriptions of
  algorithms or techniques to go hand-in-hand with concrete
  implementations.  These environments range from in-class
  presentations with accompanying algorithmic implementations, to
  online tutorials or experiential blogs with accompanying
  instructions.

In all of the situations described above prose alone in the absence of
access to code is insufficient.
#+begin_quote
[natural language is] not conducive to succinct, exact expression and
the audience is separated from the actions and details of the
algorithm and often forced to make assumptions about the precise
computational details

\attrib{Gentleman, Temple Lang}
#+end_quote

Similarly distribution of code without expository prose is not a
sufficient medium for communication between people.
#+begin_quote
Let us change our traditional attitude to the construction of
programs: Instead of imagining that our main task is to instruct a
computer what to do, let us concentrate rather on explaining to human
beings what we want a computer to do.
  
\attrib{Donald Knuth}
#+end_quote

The need for combined authoring of prose and code has been
historically approached form two different standpoints.

- Literate Programming :: enhances traditional software development
     with the addition of prose in an attempt to improve documentation
     quality.
- Reproducible Research :: adds executable code to publications of
     scholarly work, with the aim of allowing the analysis described
     in the paper to be re-run by readers.

Babel provides a unified environment supporting all manner of the
composition and application of combined prose and code (see Table
\ref{grid}).

#+LaTeX: \begin{table*}
#+ATTR_LaTeX: align=l|l|l|
|             | prose                        | code                            |
|-------------+------------------------------+---------------------------------|
| composition | natural document authoring   | natural code authoring through  |
|             | environment through Org-mode | Emacs major modes               |
|-------------+------------------------------+---------------------------------|
| application | automated publishing to      | in-situ interactive execution   |
|             | a variety of document        | as well as the tangling of code |
|             | and slideshow formats        | for external use                |
|-------------+------------------------------+---------------------------------|
#+LaTeX: \label{grid}
#+LaTeX: \end{table*}

With Babel the entire life cycle of a research or development project
can take place within a single document.  With the data, code and text
of a project stored in a single location which can be exported to a
variety of formats the future reproducibility of the work is ensured,
and the practices of Reproducible Research and Literate Programming
are encouraged by greatly reducing the burden on the author.

Babel takes it's name from the story of the /Tower of Babel/, in which
God frustrates the ambitions of man with a confusion of languages, and
the /babel-fish/ which relieves these same linguistic frustrations.
#+begin_quote
The LORD said, "If as one people speaking the same language they have
begun to do this, then nothing they plan to do will be impossible for
them.  Come, let us go down and confuse their language so they will
not understand each other."

\attrib{Genesis-11}
#+end_quote
#+begin_quote
The Babel Fish is small, yellow, and simultaneously translates from
one spoken language to another

\attrib{The Hitchhiker's Guide to the Galaxy}
#+end_quote

In the remainder of this paper we will first review the idea of the
/compendium/ -- a description of the requirements of a tool for
Reproducible Research as set forth by Gentleman and Temple Lang
\cite{compendium} (Section \ref{compendium}).  We will then briefly
review the relevant tools currently in existence which each address
some subset of the use cases surrounding the use and composition of
combined prose and code (Section \ref{existing-tools}).

We will describe Org-mode (Section \ref{org-mode}) and Babel (Section
\ref{babel}) and present an argument for why we believe that they
represent a sea change in software support for authoring of combined
prose and code.  Finally we will demonstrate the application of Babel
to a number of common use cases (Section \ref{applications}), and
conclude with a discussion of the limits of Babel and pointers for
future work (Section \ref{conclusion}).

* Background
** Compendium
   :PROPERTIES:
   :CUSTOM_ID: compendium
   :END:
Gentleman and Temple Lang introduce the /compendium/ \cite{compendium}
as a proposed tool supporting reproducible research.  In their
formulation a compendium is a container holding the text, code, and
data constituting a scholarly work.  Compendiums are intended to
facilitate the distribution, management, recreation, and extension of
such works.

A compendium would also supports a variety of different /views/, where
/views/ are static documents automatically generated by /running/ the
compendium.  Examples of views would be an article submitted for
publication, or a presentation or lecture based on the work.

Gentleman and Temple Lang propose the adoption of compendiums as the
new unit of peer review and distribution of scientific work.

#+begin_quote
  The compendium concept, and that of reproducible research, has the
  potential to improve the state of publication about computational
  science. The tools we have proposed and discussed will allow us to
  move from an era of advertisement to one where our scholarship
  itself is published. This exposes the computations themselves to the
  scientific method and enhances the potential for iterative
  refinement and extension.
#+end_quote

Under their formulation a compendium would consist of the following
elements.
1) Authoring Software
2) Auxiliary Software
3) Transformation Software
4) Quality control Software
5) Distribution Software

Babel (including Org-mode and Emacs) in combination with a traditional
version control tool satisfied all of these requirements.  In addition
Babel handles three of the four points laid out in their proposed
"Future Work", namely /multiple languages/, /conditional chunks/
(where "chunks" are blocks of text or code), and /interactivity/
meaning that the code can be executed from within the authoring
environment.

Our description of the design of Babel \ref{babel} will touch on each
of these points.  First we review existing related tools.

** Existing Tools
   :PROPERTIES:
   :CUSTOM_ID: existing-tools
   :END:
Each of the tools listed below addresses a particular view of
requirement for unified authoring and publication of code and prose.

*** Automatic Documentation
The most commonly used tools for literate programming come in the form
of language specific comment extraction and automated documentation
systems.  Comment extraction tools can be used to extract
documentation from comments embedded in pure code documents.  Most
major modern programming languages are supported by a comment
extraction tools (e.g. Doxygen, Javadocs, Rubydocs, etc...).

Although notorious for the poor quality of the resulting documentation
automated comment extraction provides much practical benefit mainly
through the fact that by placing almost no burden on programmers,
these systems are widely used, and in practice have had more impact on
the software development community at large than any other tools which
will be discussed herein.

*** Web
Literate Programming \cite{web} is the practice of writing computer
programs in such a way that the main objective is to explain to a
human reader what the program is intended to do.  Literate programming
consists of embedding code inside of a prose document written in the
TeX document authoring syntax.  Programs written in this manner can be
- tangled :: resulting in a code file suitable for use by a computer
- woven :: resulting in a text document suitable for use by a person

The Web family of tools enables Literate Programming.  The initial
=WEB= tool only worked with the Pascal programming language.  Newer
versions such as =Noweb= can handle arbitrary programming languages.
Web tools enable the /authoring/ of both prose and code, but provide
no facilities for the execution of code from within documents.

*** Sweave
Like Web documents Sweave documents consist of code embedded into TeX
documents \cite{sweave}.  Sweave only supports the R statistical
programming language.  The code in Sweave documents is executed during
publishing and can be used to automatically generate tables, graphical
figures, and inline results.  As such Sweave enables the reader of a
Sweave document to trace the origins of an interesting inline value or
figure back to the relevant R computations and through to the original
data.

Sweave (and the R community at large) inspired the work which first
formulated the /compendium/ idea.  In large part the recent resurgence
in RR owes much to the success of both R and Sweave.

*** Field
Up until this point we have focused on the benefits of mixing natural
language, and programming languages, but have not addressed the
intermingling of multiple programming languages.  Support for multiple
languages is mentioned in the "Future Work" section in the description
of /compendiums/ as a feature which would greatly facilitate the
practices of reproducible research by encouraging researchers to
perform /all/ of their computation from within the environment of the
compendium.

While no RR tools currently support the intermingling of multiple
programming languages, it is a topic of growing popularity in the
software development community at large.  Many languages are being
ported to the JVM because it provides a single environment in which
multiple languages can share libraries \cite{jvm-multi-lang}.

Field [fn:: http://openendedgroup.com/field/] is a text editor based
on research started at the MIT media lab [fn::
http://www.media.mit.edu/].  Field allows code from multiple
programming languages (with a strong focus on the Jython Python
variant and Java) to be intermingled in the same document.  Currently
Field does not support exporting to human-readable documents, and
Field only supports languages which run on the JVM.

We will discuss Babel's multi-language support in Section
\ref{languages}.

* Babel
Babel is nested inside of Org-mode [fn:: http://orgmode.org] which is
itself contained inside the Emacs text editor [fn::
http://www.gnu.org/software/emacs/].  Babel gains much from executing
in this environment.

The Emacs text editor \cite{emacs} has been under constant development
since the mid 1970s.  For many of it's users Emacs is already the
preferred environment for authoring of text in all forms both
programming languages and prose -- often through writing /markup/
languages like LaTeX or HTML.  Org-mode extends Emacs with a simple
markup language which can export to a variety of formats.  Through
living inside of (and standing on the shoulders of) these projects,
Babel is able to leverage the editing and code evaluating
functionality of Emacs accessible from inside of a single Org-mode
document containing both code and prose.

Through making it possible to adopt literate programming and
reproducible research practices while retaining a familiar editing
environment Babel significantly lowers the barrier of entry.
Difficulty of use/adoption has served as a major barrier to previous
LP and RR systems, and the authors believe that because of this ease
of adoption represents along with the universal applicability across
programming languages Babel represents a qualitative advancement for
the LP/RR tools.

We will first introduce Org-mode with a focus on those features that
make it an ideal environment in which to embed a LP/RR system (Section
\ref{org-mode}).  We then describe the syntax with which code can be
embedded within Org-mode documents (Section \ref{syntax}), the
evaluation of code (Section \ref{meta-lang}), the process of exporting
(weaving and tangling) from Babel documents (Section \ref{export}),
and Babels multi-lingual support (Section \ref{languages}).

** Org-mode
   :PROPERTIES:
   :CUSTOM_ID: org-mode
   :END:
Thank you Carsten!

- readable markup language
- export targets (html, latex, beamer, ascii)
- project/task management
- editable source code
- spreadsheets
- more?

** Babel
   :PROPERTIES:
   :CUSTOM_ID: babel
   :END:
*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax
    :END:

With Babel, Org-mode documents become environments for computation as
well as containers for prose, code and data.  Certain components of
Org-mode documents are /activated/, meaning that they can be used in
Babel computations.  These components include /data/, stored in tables
or in example sections, as well as /code/ which is located in
specially marked code blocks.  Each of these elements can be /named/
allowing them to be referenced by other elements in the Babel
execution environment.  The following syntax is used to incorporate
these features into Org-mode's existing plain text markup scheme.

- table data :: Tables constructed as described in Section
     \ref{org-mode} can be named with preceeding =#+tblname:= or the
     more general =#+results:= lines.  For example the following
     org-mode syntax
     #+begin_src org
       ,#+results: numbered-primes
       ,| 1 |  2 |
       ,| 2 |  3 |
       ,| 3 |  5 |
       ,| 4 |  7 |
       ,| 5 | 11 |
     #+end_src
     can be referenced by other Babel elements and manipulated as a 2D
     matrix of numbers.

- example data :: Org-mode /example/ blocks named using =#+results:=
     lines can also be referenced by Babel.  For example, the
     following simple example block would be interpreted as a number.
     #+begin_src org
       ,#+results: the-magic-number
       ,: 24
     #+end_src
     larger blocks of text can also be named and accessed from babel.
     The following "block" syntax variation is semantically equivalent
     to the =:= prefixing demonstrated above.
     #+begin_src org
       ,#+results: larger-block-of-text
       ,#+begin_example
       ,  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
       ,  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
       ,  enimad minim veniam, quis nostrud exercitation ullamco laboris nisi
       ,  ut aliquip ex ea commodo consequat. Duis aute irure dolor in
       ,  reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
       ,  pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
       ,  culpa qui officia deserunt mollit anim id est laborum.
       ,#+end_example
     #+end_src

- block code :: Source code in a variety of languages (see Section
     \ref{languages}) can be embedded into Org-mode documents using
     the following syntax.
     #+begin_src org
       ,#+srcname: <name>
       ,#+begin_src <language> <switches> <header arguments>
       ,  <body>
       ,#+end_src
     #+end_src
     where
     - <name> :: This name is associated with the code block.  This is
          similar to the =#+tblname= lines that can be used to name
          tables in Org-mode files.  Referencing the name of a code
          block makes it possible to evaluate the block from other
          places in the file, other files, or from Org-mode table
          formulas.
     - <language> :: The language of the code in the block.
     - <switches> :: Switches controling exportation of the code block
     - <header arguments> :: Optional header arguments control many
          aspects of evaluation, export and tangling of code blocks.
     - <body> :: The source code.

Extensive documentation of the Babel specific syntax is available in
the babel manual [fn:: http://orgmode.org].

*** Code Evaluation
    :PROPERTIES:
    :CUSTOM_ID: meta-lang
    :END:

Babel knows how to evaluate code from a number of languages.  In the
evaluation of source code Babel makes use of a great deal of existing
Emacs support for interactive with both external and inferior
processes.

As an example the following block of ruby code
#+caption: A simple block of ruby code before evaluation.
#+label: ruby-simple
#+begin_src org
  ,#+begin_src ruby
  ,  require 'date'
  ,  "This block was last evaluated on #{Date.today}"
  ,#+end_src
#+end_src
would be evaluated by
1) writing it's contents to a temporary file
2) using the =ruby= command to execute the file
3) capturing the return value of the code block

By default the captured output appears in the Org-mode buffer
immediately following the code block, resulting in the following
#+caption: A simple block of ruby code after evaluation.
#+label: ruby-simple-run
#+begin_src org
  ,#+begin_src ruby
  ,  require 'date'
  ,  "This block was last evaluated on #{Date.today}"
  ,#+end_src
  
  ,#+results:
  ,: This block was last evaluated on 2010-06-25
#+end_src

**** Sessions
The same code could also be evaluated in an interactive session
through adding a session /header argument/, e.g.
#+begin_src org
  ,#+begin_src ruby :session
  ,  require 'date'
  ,  "This block was last evaluated on #{Date.today}"
  ,#+end_src
#+end_src
in this case the code would be evaluated by
1) starting a persistent ruby process associated with a new Emacs buffer
2) passing the code body to that process
3) capturing the last value returned by that process

Session evaluation can be useful when the code block changes some
state the retention of which is desirable for manual inspection, or
for use by later code blocks.  For example in the following example
the first block of =R= code sets variables in an interactive session
and the second block of =R= code can access these variables because it
is run in the /same =R= session/ (take from [fn::
http://orgmode.org/worg/org-contrib/babel/uses.php#foo]).

#+label: R-pair
#+begin_src org
  ,#+begin_src R :session *R* :results silent
  ,  n <- 50
  ,  x <- seq(1, n)
  ,  a.true <- 3
  ,  b.true <- 1.5
  ,  y.true <- a.true + b.true * x
  ,  s.true <- 17.3
  ,  y <- y.true + s.true * rnorm(n)
  ,  out1 <- lm(y ~ x)
  ,  summary(out1)
  ,#+end_src
  
  ,the previous block builds an environment consisting of a number of
  ,variables referenced by the subsequent block
  
  ,#+begin_src R :session *R* :file fig.pdf
  ,  plot(x, y)
  ,  abline(out1)
  ,#+end_src
#+end_src

Session based evaluation is similar to the approach to evaluation
taken by =Sweave= in which every code block is evaluated in the same
persistent session -- with the main difference that Babel allows for
multiple disjoint named sessions.

**** Results
The previous example (Figure \ref{R-pair}) made use of two header
arguments which we have not discussed -- =results= and =file=.  Both
of these arguments control how the results of a code block are
handled.  As seen in (Figure \ref{ruby-simple-run}), by default
results of code blocks are inserted as protected text in an Org-mode
buffer.  In fact the user is given significant control over the
handling of code block results both during interactive evaluation and
during export.

There are two ways in which results can be collected from code blocks.
- =:results value= :: Specifies that the code block should be treated
     as a function, and the results should be equal to the value of
     the last expression in the blocks, like the return value of a
     function.  This is the default setting.  The following block
     demonstrates /value/ based result collection.
     #+begin_src org
       ,#+begin_src perl
       ,  $x = 8;
       ,  $x = $x + 1;
       ,  print "shouting into the dark!\n";
       ,  $x
       ,#+end_src
       
       ,#+results:
       ,: 9
     #+end_src
- =:results output= :: Specifies that the results should be collected
     from STDOUT, which allows code blocks to incrementally print
     their output as in the following.
     #+begin_src org
       ,#+begin_src python :results output
       ,  for x in ['cat', 'window', 'defenestrate']:
       ,      print x, len(x)
       ,#+end_src
       
       ,#+results:
       ,: cat 3
       ,: window 6
       ,: defenestrate 12
     #+end_src

Results can take a number of different forms.  So far we have only
seen string results, however it is possible for return vector results.
Babel recognizes vector results and inserts them as tables into the
Org-mode buffer as in Figure \ref{vector-results}.

#+label: vector-results
#+begin_src org
  ,#+begin_src ruby
  ,  [1, 2, 3, 4, 5]
  ,#+end_src
  
  ,#+results:
  ,| 1 | 2 | 3 | 4 | 5 |
  
  ,#+begin_src ruby
  ,  [1, 2, 3, 4, 5].map{|n| [n, 2*n]}
  ,#+end_src
  
  ,#+results:
  ,| 1 |  2 |
  ,| 2 |  4 |
  ,| 3 |  6 |
  ,| 4 |  8 |
  ,| 5 | 10 |
#+end_src

Additionally some code blocks may output files or images.  Babel is
able to save these types of results in external files, and then link
to these files from the Org-mode buffer.  In this way the resulting
files can be opened from within the document and included in exports.
Returning to the second block from Figure \ref{R-pair}.  It's
evaluation results in the following.
#+begin_src org
  ,#+begin_src R :session *R* :file fig.pdf
  ,  plot(x, y)
  ,  abline(out1)
  ,#+end_src
  
  ,#+results:
  ,[[file:fig.pdf]]
#+end_src

Much more information about controlling the evaluation of code and the
handling of code results is available in the Babel documentation.

**** Arguments
*** Export
    :PROPERTIES:
    :CUSTOM_ID: export
    :END:
*** language support
    :PROPERTIES:
    :CUSTOM_ID: languages
    :END:
- currently supports over 20 languages
- number of supported languages are growing, and it's easy enough to
  add new ones that most language support at this point is user
  submitted

** Applications
   :PROPERTIES:
   :CUSTOM_ID: applications
   :END:
- simple example with multi-language block chaining and producing a
  figure
- example with tangling
- pointer to foo.Rnw and foo.org
- look at uses for some more ideas

* Conclusion
  :PROPERTIES:
  :CUSTOM_ID: conclusion
  :END:
Babel certainly has a number of natural limits.  While Emacs
provides a number of extremely mature and full featured environment
for authoring of code and text, and for controlling the evaluation of
text, it also brings with it a number of limiting factors.
- steep learning curve
- small community of potential users
- it's not the best execution VM or sublayer
  - single threaded
  - inefficient

Given the comfortable environment of Emacs and Org-mode, Babel
provides an environment for the co-mingling of code, data, and prose
in such a way that a critical mas has been reached -- "It's actually
comfortable enough for real people to want to use it for their daily
work!".

As such we believe it is a great step forward for the RR and LP camps,
and has the potential to significantly increase the widespread
acceptance of these approaches to doing scientific work and
development.  It is the authors ultimate hope that this work will
ultimately help to increase communication and help developers and
scientists to make their work more accessible.

#+begin_LaTeX
  \bibliographystyle{abbrv}
  \small
  \bibliography{babel}
#+end_LaTeX
