# -*- mode: org, org-export-latex-listings: t -*-
#+TITLE: Babel /DRAFT/
#+AUTHOR: 
#+OPTIONS: ^:nil toc:nil H:4
#+STARTUP: oddeven hideblocks
#+STYLE: <link rel="stylesheet" href="http://cs.unm.edu/~eschulte/classes/emacs.css" type="text/css"/>  
#+LATEX_HEADER: \usepackage{attrib}
#+LATEX_HEADER: \usepackage{mathpazo}
#+LATEX_HEADER: \usepackage{listings}
#+LaTeX_CLASS: twocolumn
#+begin_latex
  \lstdefinelanguage{org}
  {
    morekeywords={:results, :session, :var, :noweb, :exports},
    sensitive=false,
    morecomment=[l]{\#},
    morestring=[b]",
  }
  \hypersetup{
    linkcolor=blue,
    pdfborder={0 0 0 0}
  }
  \renewcommand\t[1]{{\tt #1}}
  \newcommand\ATCES{{\sf atce/r}}
  \newcommand\lt[1]{{\lstinline+#1+}}
  \definecolor{dkgreen}{rgb}{0,0.5,0}
  \definecolor{dkred}{rgb}{0.5,0,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \lstset{basicstyle=\ttfamily\bfseries\scriptsize,
    morekeywords={virtualinvoke,fucompp,fnstsw,fldl,fstpl,movl},
    keywordstyle=\color{blue},
    ndkeywordstyle=\color{red},
    commentstyle=\color{dkred},
    stringstyle=\color{dkgreen},
    numbers=left,
    numberstyle=\ttfamily\footnotesize\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{white},
    tabsize=4,
    showspaces=false,
    showstringspaces=false,
    xleftmargin=.23in
  }
#+end_latex

#+LaTeX: \begin{abstract}
We present a new computing environment for authoring mixed natural and
computer language documents. In this environment a single
hierarchically-organized plain text source file may contain a variety
of elements such as code in arbitrary programming languages, raw data,
links to external resources, project management data, working notes,
and text for publication. Code fragments may be executed in situ with
graphical and text output captured in, or linked to, the file. Export
to LaTeX, HTML, Beamer, DocBook and other formats permits working
reports, presentations and manuscripts for publication to be generated
from the file. In addition, code extraction (tangling) permits
functioning pure code files to be extracted from the file. This
environment is implemented as an extension to the Emacs text editor
and provides a rich set of features for authoring both prose and code,
as well as sophisticated project management capabilities.
#+LaTeX: \end{abstract}

* Introduction
There are a variety of settings in which it is desirable to mix prose
and code in a single container.
- /Scientific research/ increasingly involves the use of computational
  tools, the inclusion of which is vital to successful communication
  and verification of research results.
- In /software development/ the exchange of ideas is accomplished
  through both shared code and prose; code provides 
  concrete and succinct description and prose provides higher level
  explanation.  Without proper documentation the usability and future
  extensibility of computational tools are severely compromised.
- In /pedagogical/ environments it is important for descriptions of
  algorithms or techniques to go hand-in-hand with concrete
  implementations.  These environments range from in-class
  presentations with accompanying algorithmic implementations, to
  online tutorials or experiential blogs with accompanying
  instructions.

In each of the situations described above, prose alone in the absence of
code is typically insufficient.  Similarly, distribution of code
without expository prose is a less than ideal medium for communication
between people. In this paper we describe Babel, which provides a
unified environment that supports many different approaches to
composition and application of combined prose and code (Table
\ref{grid}).  Babel is implemented as part of the Org-mode plain text
markup language, which provides the high level structure of Babel
documents and many of export functions.  Babel and Org-mode are
designed for ease of use and adoption.  The Babel environment aims to
be a general solution for authoring projects with mixed computational
and natural languages.  It supports multiple languages, export
targets, and work flows.

#+LaTeX: \begin{table*}
#+ATTR_LaTeX: align=l|l|l|

|             | prose                        | code                            |
|-------------+------------------------------+---------------------------------|
| composition | natural document authoring   | natural code authoring through  |
|             | environment through Org-mode | Emacs major modes               |
|-------------+------------------------------+---------------------------------|
| application | automated publishing to      | in-situ interactive execution   |
|             | a variety of document        | as well as the tangling of code |
|             | and slideshow formats        | for external use                |
|-------------+------------------------------+---------------------------------|
#+LaTeX: \label{grid}
#+LaTeX: \end{table*}

# With Babel the entire life cycle of a research or development
# project can take place within a single document.  With the data,
# code and text of a project stored in a single location which can be
# exported to a variety of formats, the future reproducibility of the
# work is ensured, and the practices of Reproducible Research and
# Literate Programming are encouraged by greatly reducing the burden
# on the author.
# 
# I didn't quite understand the last part of the preceding sentence (Dan)
Here we review existing approaches to the combined authoring of prose
and code, including software tools designed to address one or more of
the use cases for mixed natural and computer language documents
(Section \ref{background}).  We then describe the design of Babel
(Section \ref{design}) and Org-mode (Section \ref{org-mode}), and
# This is the first mention of "Org-mode". Needs some prior
# introductory sentence.
demonstrate their application to some common use cases (Section
\ref{applications}).  We conclude with a discussion of why we believe
Babel constitutes a uniquely productive environment for authoring
mixed prose and code projects (Section \ref{points-for}), as well as
some limits of the current implementation and directions for future
work (Section \ref{future-work}).

* Background
  :PROPERTIES:
  :CUSTOM_ID: background
  :END:
The combined authoring of prose and code has been historically
approached from two different standpoints.

- Literate Programming :: enhances traditional software development by
     embedding code in explanatory essays and treating the act of
     development as one of communication with future maintainers.

- Reproducible Research :: embeds executable code in publications of
     scholarly work, with the aim of allowing the analysis described
     in the paper to be re-run by readers.

We discuss each of these approaches in turn including a review of
existing software tools that support each technique.

** Literate Programming
#+begin_quote
Let us change our traditional attitude to the construction of
programs: Instead of imagining that our main task is to instruct a
computer what to do, let us concentrate rather on explaining to human
beings what we want a computer to do.

\attrib{Donald E. Knuth}
#+end_quote

The technique of /literate programming/ was introduced by Donald Knuth
\cite{web} in the early 1980's, not long after his creation of the TeX
typesetting software.  The goals of literate programming are to
encourage the author of a computational work to approach the project
"as an essayist, whose main concern is with exposition and excellence
of style". 
# need citation with page number

Accordingly, literate programming tools use input files that mix
sections of computer code with sections of natural language typically
marked up in TeX or LaTeX.  The literate programming tool then provides a
number of methods for the creation of two types of /view/ into the
document; articles intended for human consumption that consist of
typset prose and marked-up code blocks, and computer readable
documents of pure source code.  The literate programming terms for
generating these views are /weaving/ and /tangling/ respectively.  A
common feature of literate programming tools is the ability to
organize code blocks differently when /tangling/ and /weaving/ thereby
allowing the programmer to introduce concepts to humans in a different
order than code is introduced to the computer.

The original literate programming tool, developed by Knuth, was =WEB=,
which consists of two primary programs, =TANGLE= and =WEAVE=.  This
system supported the Pascal programming language and produced
documents typeset with TeX.  A modern descendent is =noweb=
\cite{noweb} which is designed to be language independent.  Its
primary programs, =notangle= and =noweave=, are both written in =C=.
Documents produced by =noweave= can be typeset with =TeX=, =LaTeX=,
and =troff= or displayed in a web browser as =HTML=.  Software tools
such as =WEB= and =noweb= enable the /authoring/ of both prose and
code, but do not provide facilities for the execution of code from
within documents.  Instead, code intended for execution is tangled and
the resulting source code files are sent to a compiler or interpreter.

** Reproducible Research
#+begin_quote
An article about computational science in a scientific publication is
*not* the scholarship itself, it is merely *advertising* of the
scholarship.  The actual scholarship is the complete software
development environment and complete set of instructions which
generated the figures.

\attrib{David L. Donoho}
#+end_quote

A research project typically produces one or more documents that
describe or rely upon:
  - a data collection
  - computations and code used in data analysis or simulation
  - methodological conventions and assumptions
  - decisions among alternate analytic paths

The documents produced by a research project typically stand apart
from the things they describe and rely upon, which makes it difficult
for other researchers to understand fully or to reproduce the results
of the research project.
 
A software solution to this problem was proposed by Gentleman and
Temple Lang, who "introduce the concept of a /compendium/ as both a
container for the different elements that make up the document and its
computations (i.e. text, code, data, ...), and as a means for
distributing, managing and updating the collection."  They
summarize the uses and implications of a compendium:

  - it encapsulates the actual work of the author, not just an
    abridged version suitable for publication; 

  - it can display different levels of detail in /derived documents/; 

  - the computations included in it can be re-run by an interested
    reader, potentially with different inputs;

  - it contains explicit computational details that make it easier for
    an interested reader to adapt and extend the methods;

  - it enables programmatic construction of plots and tables; 

  - its components can be treated as data or inputs to software and
    manipulated programmatically in ways perhaps not envisioned by
    the author.

/Reproducible research/ thus approaches mixed natural and
computational language documents from a different direction than
literate programming.  Rather than adding prose to computational
projects, reproducible research seeks to augment publications of
scientific research with the computer code used during conduct of the
research.  Where literate programming tangles embedded code into an
external file used as input to a compiler or an interpreter, code
embedded in reproducible research is intended to be executed as part
of the document generation process.  In this way the data, analysis,
and figures supporting a publication can be generated from the
publication itself.

# The requirements of a tool supporting reproducible research are
# thoroughly explored by Gentleman and Temple Lang, and presented in the
# concept of a /compendium/ \cite{compendium}.  In their formulation a
# compendium is a container that holds the text, code, and raw data
# constituting a scholarly work.  Compendia are intended to facilitate
# the distribution, management, re-creation, and extension of such
# works.

# A compendium would also support a variety of different /views/, where
# /views/ are static documents automatically generated by /running/ the
# compendium.  Examples of views would be an article submitted for
# publication, or a presentation or lecture based on the work.

Gentleman and Temple Lang propose the adoption of compendia as the
new unit of peer review and distribution of scientific work.

#+begin_quote
The compendium concept, and that of reproducible research, has the
potential to improve the state of publication about computational
science. The tools we have proposed and discussed will allow us to
move from an era of advertisement to one where our scholarship itself
is published. This exposes the computations themselves to the
scientific method and enhances the potential for iterative refinement
and extension.

\attrib{Gentleman and Temple Lang}
#+end_quote

=Sweave= \cite{sweave} is a modern software tool, written in the =R=
statistical programming language, that can be used for reproducible
research.  =Sweave= (and the =R= community at large) inspired the work
which first formulated the /compendium/ idea.  In large part, the
recent resurgence in reproducible research owes much to the success of
both =R= and =Sweave=.  =Sweave= documents consist of code blocks of
the =R= statistical programming language embedded into LaTeX
documents.  The =R= functions that make up =Sweave= execute the
embedded =R= code and produce a LaTeX document that includes the
resulting tables, graphical figures, and inline results.  If the
=Sweave= document is accompanied by the data files used in the
statistical computations and any =R= language files that are sourced,
then the reader can trace a result back to the relevant =R=
computations and through to the original data.

# It might be useful to start this section with Lisp and how bottom-up
# programming changes the language to suit the problem.  So emacs
# turned lisp into a language for writing editors, org-mode turned it
# into a language for parsing hierarchical documents, etc., and babel
# turned it into a language for literate programming and reproducible
# research. (no attempt to be precise or exhaustive here).
* Design and Usage
  :PROPERTIES:
  :CUSTOM_ID: design
  :END:
Babel is nested inside of Org-mode [fn:: http://orgmode.org] which is
itself contained inside the Emacs text editor [fn::
http://www.gnu.org/software/emacs/].  Babel gains much from executing
in this environment.

The Emacs text editor \cite{emacs} has been under constant development
since the mid 1970s.  For many of its users Emacs is already the
preferred environment for authoring text in all forms---both
programming languages and prose---often through writing /markup/
languages like LaTeX or HTML.  Org-mode extends Emacs with a simple
markup language, supporting a rich set of features in areas such as
text structuring, project management and publishing, which can export
to a variety of formats.  Through living inside of (and standing on
the shoulders of) these projects, Babel is able to leverage the
editing functionality of Emacs from inside an Org-mode document
containing both code and prose.

Through making it possible to adopt literate programming and
reproducible research practices while retaining a familiar editing
environment, Babel significantly lowers the barrier of entry.
Difficulty of use/adoption has served as a major barrier to previous
LP and RR systems, and we believe that with this ease of adoption,
along with the universal applicability across programming languages,
Babel represents a significant, qualitative advance in the design of
LP/RR tools.

We will first introduce Org-mode with a focus on those features that
make it an ideal environment in which to embed a LP/RR system (Section
\ref{org-mode}).  We then describe the syntax with which code can be
embedded within Org-mode documents (Section \ref{syntax}), the
evaluation of code (Section \ref{code-blocks}), the process of exporting
(weaving and tangling) from Babel documents (Section \ref{export}),
and Babel's multi-lingual support (Section \ref{languages}).

** Org-mode
   :PROPERTIES:
   :CUSTOM_ID: org-mode
   :END:
Thank you Carsten!

- readable markup language
- export targets (html, latex, beamer, ascii)
- project/task management
- editable source code
- spreadsheets
- more?

** Code Blocks
    :PROPERTIES:
    :CUSTOM_ID: code-blocks
    :END:
*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax
    :END:

With Babel, Org-mode documents become environments for computation as
well as containers for prose, code and data.  Certain components of
Org-mode documents are /activated/, meaning that they can be used in
Babel computations.  These components include /data/, stored in tables
in example sections or linked from external files, as well as /code/
which is located in specially marked code blocks.  Each of these
elements can be /named/ allowing them to be referenced by other
elements in the Babel execution environment.  The following syntax is
used to incorporate these features into Org-mode's existing plain text
markup scheme.

- table data :: Tables constructed as described in Section
     \ref{org-mode} can be named with preceding =#+tblname:= or
     =#+results:= lines.  For example the following Org-mode syntax
     #+begin_src org
       ,#+results: numbered-primes
       ,| 1 |  2 |
       ,| 2 |  3 |
       ,| 3 |  5 |
       ,| 4 |  7 |
       ,| 5 | 11 |
     #+end_src
     can be referenced by other Babel elements and manipulated as a 2D
     matrix of numbers.

- example data :: Org-mode /example/ blocks named using =#+results:=
     lines can also be referenced by Babel.  For example, the
     following simple example block would be interpreted as a number.
     #+begin_src org
       ,#+results: the-magic-number
       ,: 24
     #+end_src
     Larger blocks of text can also be named and accessed from babel.
     The following "block" syntax variation is semantically equivalent
     to the =:= prefixing demonstrated above.
     #+begin_src org
       ,#+results: larger-block-of-text
       ,#+begin_example
       ,  Lorem ipsum dolor sit amet, consectetur
       ,  adipisicing elit, sed do eiusmod tempor
       ,  incididunt ut labore et dolore magna
       ,  aliqua.
       ,#+end_example
     #+end_src

- linked data :: Org-mode /link/ syntax can be used to reference
     external data in an external file.
     #+begin_src org
       ,#+results: linked-data
       ,[[http://external-data.org]]
     #+end_src

- block code :: Source code in a variety of languages (see Section
     \ref{languages}) can be embedded into Org-mode documents using
     the following syntax.
     #+begin_src org
       ,#+srcname: <name>
       ,#+begin_src <language> <header arguments>
       ,  <body>
       ,#+end_src
     #+end_src
     where
     - name :: This name is associated with the code block.  This is
          similar to the =#+tblname= lines that can be used to name
          tables in Org-mode files.  Referencing the name of a code
          block makes it possible to evaluate the block from other
          places in the file, other files, or from Org-mode table
          formulas.
     - language :: The language of the code in the block.
     - header arguments :: Optional header arguments control many
          aspects of evaluation, export and tangling of code blocks.
     - body :: The source code.

Extensive documentation of the Babel-specific syntax is available in
the Babel manual [fn:: http://orgmode.org].

*** Evaluation
Babel knows how to evaluate code written in a number of languages.  In
the evaluation of source code Babel makes use of a great deal of
existing Emacs support for interaction with languages running as both
external and inferior (Emacs-internal) processes.
# I used "interpreters" but this may be a technical term that is too restrictive (Dan)
# I removed "interpreters" because we also run compiled languages e.g. C (Eric)

#+begin_src org
  ,#+begin_src ruby
  ,  require 'date'
  ,  "This block was last evaluated on #{Date.today}"
  ,#+end_src
#+end_src

As an example the block of ruby code shown above would be evaluated by
1) writing its contents to a temporary file
2) using the =ruby= command to execute the file
3) capturing the return value of the code block

By default the captured output appears in the Org-mode buffer
immediately following the code block, resulting in the following
#+begin_src org
  ,#+begin_src ruby
  ,  require 'date'
  ,  "This block was last evaluated on #{Date.today}"
  ,#+end_src
  
  ,#+results:
  ,: This block was last evaluated on 2010-06-25
#+end_src

The same code could also be evaluated in an interactive session
through adding a session /header argument/, e.g.
#+begin_src org
  ,#+begin_src ruby :session
  ,  require 'date'
  ,  "This block was last evaluated on #{Date.today}"
  ,#+end_src
#+end_src
in this case the code would be evaluated by
1) starting a persistent =ruby= process associated with a new Emacs
   buffer
2) passing the code body to that process
3) capturing the last value returned by that process

Session evaluation can be useful when the code block changes some
state the retention of which is desirable for manual inspection, or
for use by subsequent code blocks.  For example the first block of =R=
code below sets variables in an interactive session and the second
block of =R= code can access these variables because it is run in the
same =R= session (adapted from [fn::
http://www.stat.umn.edu/~charlie/Sweave/]).

#+begin_src org
  ,#+begin_src R :session *R* :results silent
  ,  n <- 50
  ,  x <- seq(1, n)
  ,  a.true <- 3
  ,  b.true <- 1.5
  ,  y.true <- a.true + b.true * x
  ,  s.true <- 17.3
  ,  y <- y.true + s.true * rnorm(n)
  ,  out1 <- lm(y ~ x)
  ,  summary(out1)
  ,#+end_src
  
  ,the previous block builds an environment
  ,consisting of a number of variables referenced by
  ,the subsequent block
  
  ,#+begin_src R :session *R* :file fig.pdf
  ,  plot(x, y)
  ,  abline(out1)
  ,#+end_src
#+end_src

Session-based evaluation is similar to the approach to evaluation
taken by =Sweave= in which every code block is evaluated in the same
persistent session---with the main difference being that Babel allows
for multiple disjoint named sessions.

*** Results
The previous example made use of two header arguments which we have
not discussed -- =results= and =file=.  Both of these arguments
control how the results of a code block are handled.  As seen in the
ruby evaluation example above, by default results of code blocks are
inserted as protected text immediately after the code block in the
Org-mode buffer.  In practice the user is given significant control
over the handling of code block results both during interactive
evaluation and during export.

There are two ways in which results can be collected from code blocks.
- =:results value= :: Specifies that the code block should be treated
     as a function, and the results should be equal to the value of
     the last expression in the blocks, like the return value of a
     function.  This is the default setting.  The following block
     demonstrates /value/ based result collection.
     #+begin_src org
       ,#+begin_src perl
       ,  $x = 8;
       ,  $x = $x + 1;
       ,  print "shouting into the dark!\n";
       ,  $x
       ,#+end_src
       
       ,#+results:
       ,: 9
     #+end_src
- =:results output= :: Specifies that the results should be collected
     from STDOUT, which allows code blocks to incrementally print
     their output as in the following.
     #+begin_src org
       ,#+begin_src python :results output
       ,  for x in ['Org-mode', 'Emacs']:
       ,      print x, len(x)
       ,#+end_src
       
       ,#+results:
       ,: Org-mode 8
       ,: Emacs 5
     #+end_src

Results can take a number of different forms.  So far we have only
seen string results, however it is possible for code blocks to return
vector results.  Babel recognizes vector results and inserts them as
tables into the Org-mode buffer as shown below.

#+begin_src org
  ,#+begin_src haskell
  ,  [1, 2, 3, 4, 5]
  ,#+end_src
  
  ,#+results:
  ,| 1 | 2 | 3 | 4 | 5 |
  
  ,#+begin_src haskell
  ,  zip [1..] (map (\ x -> x + 1) [1, 2, 3])
  ,#+end_src
  
  ,#+results:
  ,| 1 | 2 |
  ,| 2 | 3 |
  ,| 3 | 4 |
#+end_src

Additionally some code blocks may output files or images.  Babel is
able to save these types of results in external files, and then link
to these files from the Org-mode buffer.  In this way the resulting
files can be opened from within the document and included in exports.
For example the =R= block above which calls =plot= results in the
following link being inserted into the Org-mode buffer.
#+begin_src org
  ,#+begin_src R :session *R* :file fig.pdf
  ,  plot(x, y)
  ,  abline(out1)
  ,#+end_src
  
  ,#+results:
  ,[[file:fig.pdf]]
#+end_src

Much more information about controlling the evaluation of code and the
handling of code results is available in the Babel documentation.

*** Arguments
We've now seen how data originating in code blocks can be inserted
into Org-mode buffers in the form of /scalars/, /tables/ and /links/
to external files.  It is also possible for data to flow from each of
these containers (/scalars/, /tables/ and /links/) into code blocks,
and even for data to pass from code block to code block without ever
landing in the Org-mode buffer.

This is all made possible through a simple system of passing arguments
to code blocks.  Values passed to code blocks are then made accessible
from the source code in a language specific way, but most often in the
form of variables assigned to the values of the arguments.

The following syntax can be used to pass an argument to a code blocks.
#+begin_src org
  ,#+source: inc
  ,#+begin_src clojure :var x=10
  ,  (+ x 1)
  ,#+end_src
  
  ,#+results: inc
  ,: 11
#+end_src

In the context of this code block the value of =x= is now set to 10.
We could also use a named value elsewhere in the buffer to initialize
a variable.
#+begin_src org
  ,#+results: remote-x
  ,: some text
  
  ,Lorem ipsum dolor sit amet, consectetuer
  ,adipiscing elit.
  
  ,#+begin_src clojure :var x=remote-x
  ,  x
  ,#+end_src
  
  ,#+results:
  ,: some text
#+end_src

As these examples demonstrate, strings will be passed in a strings,
numbers as numbers, and tables will be passed in as tables.
#+begin_src org
  ,#+results: table-x
  ,| 1 | 
  ,| 2 |
  ,| 3 |
  ,| 4 |
  ,| 5 |
  
  ,#+begin_src ruby :var x=table-x
  ,  x.map{|row| row.map{|cell| cell + 1}}
  ,#+end_src
  
  ,#+results:
  ,| 2 |
  ,| 3 |
  ,| 4 |
  ,| 5 |
  ,| 6 |
#+end_src

Code blocks can reference the other code blocks.
#+begin_src org
  ,#+source: inc
  ,#+begin_src clojure :var x=10
  ,  (+ x 1)
  ,#+end_src
  
  ,#+begin_src python :var y=inc :results output
  ,  print "10 + 1 =", y
  ,#+end_src
  
  ,#+results:
  ,: 10 + 1 = 11
  
  ,In addition arguments can be passed to referenced
  ,code blocks using a traditional function syntax
  ,with named arguments.
  
  ,#+begin_src python :var y=inc(x=2) :results output
  ,  print "2 + 1 =", y
  ,#+end_src
  
  ,#+results:
  ,: 2 + 1 = 3
#+end_src

Notice that no problems are caused when code blocks of different
languages interact; this is because all values are passed through the
Emacs Lisp interpreter that is at the core of Emacs.  This argument
passing syntax allows for complex chaining of raw values in a
document, and of blocks of code in multiple languages as shown in
Section \ref{applications}.

** Export
    :PROPERTIES:
    :CUSTOM_ID: export
    :END:

Borrowing terms from the Literate Programming community Babel supports
both /weaving/ (the exportation of a mixed code/prose document to a
prose format suitable for reading by a human) and /tangling/ (the
exportation of a mixed code/prose document to a pure code file
suitable for execution by a computer).

- weaving :: Org-mode provides an extremely sophisticated and
     full-featured system of exportation to HTML, LaTeX, and a number
     of other target formats.  Babel adds support for the
     pre-processing of code blocks as part of the export process.
     This pre-processing allows for the code of a code block, the
     results of a code block, or both or neither to be included in the
     final exported document.

- tangling :: Tangling consists not only of extracting source code
     from an Org-mode document but also of re-arranging the code.
     Often the order in which a computer needs to be presented with
     code differs from the order in which the code may be best
     organized in a document.  LP systems like no-web solve this
     problem using code-block references which are expanded as part of
     the reference process \cite{noweb}.  Babel implements the same
     reference system reproducing the same syntax and functionality of
     the =noweb= reference system.

** Language support
    :PROPERTIES:
    :CUSTOM_ID: languages
    :END:

The core functions of Babel are entirely language agnostic.  The
tangling, source edit and export features of Org-babel can be used
even for unsupported languages; only code evaluation and interaction
with live sessions require language-specific functions.  Support for
new languages can be added by defining a small number of
functions named according to language, following a couple of simple
conventions.  Currently Babel has support for over 20 languages.  The
ease with which support for new languages can be added is evidenced by
the fact that all new language support has been contributed by
Org-babel users rather than by the original authors.

* Applications
   :PROPERTIES:
   :CUSTOM_ID: applications
   :END:
- simple example with multi-language block chaining and producing a
  figure
- example with tangling
- pointer to foo.Rnw and foo.org
- look at uses for some more ideas

* Discussion
  :PROPERTIES:
  :CUSTOM_ID: conclusion
  :END:
** Compendium
# TD thinks this belongs in the Discussion, rather than the section on
# reproducible research.
Under their formulation a compendium would consist of the following
elements.
1) Authoring Software
2) Auxiliary Software
3) Transformation Software
4) Quality control Software
5) Distribution Software

The Babel environment used in combination with a traditional
version control tool satisfies all of these requirements.  In addition,
Babel handles three of the four points laid out in their proposed
"Future Work", namely /multiple languages/, /conditional chunks/
(where "chunks" are blocks of text or code), and /interactivity/,
meaning that the code can be executed from within the authoring
environment.


** Strengths
   :PROPERTIES:
   :CUSTOM_ID: points-for
   :END:

A number of features of Babel which make it a good choice as a tool
for the composition of combined natural and computational language
documents.

- Open source :: Babel is both /open source/ meaning it's inner
     working are publicly visible, and further, it's copyright is
     owned by the Free Software Foundation \cite{fsf}, meaning that
     Babel, and any work deriving from Babel will always be fully open
     to public scrutiny and modification.  This is *essential* for any
     tool supporting scientific peer review.

- Friendly active community :: the Org-mode community and be extension
     the community surrounding Babel is extremely friendly, which can
     be immeasurably helpful both for newcomers trying to get
     comfortable with the tool, and for developers looking for ideas
     and feedback.  Without this community the Babel project would
     never have reached a useable state.

- General :: A leading drive in the design of Babel was pursuit of
     generality.  Babel (through Org-mode) exports to many target file
     types (e.g. LaTeX, HTML, Beamer slideshows, ASCII, etc...), it
     supports arbitrary programming languages.  It displays no
     reproducible research or literate programming bias.

- Natural :: For Emacs users a transition to using Babel will allow
     them to continue using the same editor and major modes with which
     they are already familiar.

** Weaknesses and Future Work
   :PROPERTIES:
   :CUSTOM_ID: future-work
   :END:
Babel certainly has a number of natural limits.  While Emacs provides
a number of extremely mature and full-featured environments for
authoring of code and text, and for controlling the evaluation of
text, it also brings with it a number of limiting factors.
- steep learning curve
  #+begin_comment
  Let's find a way of more nuanced way of saying that. I find that it
  gets exagerrated: Emacs has a menu with Open and Save, and when you
  hit "a" an "a" appears in the document, so in a sense how much more
  easy does it get?
  #+end_comment
- small community of users
- it's not the best execution VM or sublayer
  - single threaded
  - inefficient

These items indicate a number of paths for future work, either for
further development of Org-babel, or for any future tool of this type.

- editor agnostic :: One point where Babel is not as general as it
     could be is the range of available editing environments.  Despite
     the incredible amount of features that Emacs and Org-mode provide
     to Babel, they both also place limits on the pool of potential
     users to those who either already use Emacs and Org-mode, or are
     willing and able to adopt what can conservatively be described as
     a /sophisticated/ text editing environment.
     
     It seems that it would be possible for future tools of this
     nature to provide code evaluation and exportation as a service
     which could be called from any number of editors.  Such a
     structure would raise a number of challenging implementation
     issues.

- virtual machine :: Babel allows heterogeneous programming
     environments to share data by dropping all shared values to the
     common denominator of Emacs Lisp.  This works well for Babel as
     it allows for re-use of many pre-existing Emacs tools for
     evaluation of code in a variety of language, often making the
     addition of support for new languages trivial.

     There are however properties of Emacs Lisp which make it less
     than ideal as a medium of data exchange and as a shepherd of
     evaluation.  Most importantly the Emacs Lisp interpreter is
     /single threaded/, this makes the asynchronous evaluation of code
     blocks needlessly complex (in fact this features does not yet
     exist in Babel).
     
     Also, the execution of Emacs Lisp requires a running Emacs
     process.  There is no low-overhead method of evaluating Emacs
     Lisp in the absence of an Emacs session.  In the presence of such
     functionality it may be possible for Babel to support the
     tangling of multi-language /stand-alone executables/, further
     reducing the barrier to reproduction of works authored in Babel.
     
     Both of the above issues may be resolved naturally if Guile
     scheme replaces the existing Emacs Lisp execution engine, which
     at the time of writing seems a distinct possibility [fn::
     http://lists.gnu.org/archive/html/emacs-devel/2010-04/msg00665.html].

** Conclusion
Babel provides an environment for the co-mingling of code, data, and
prose in such a way that a critical mass has been reached -- "It's
actually comfortable enough for real people to want to use it for
their daily work!".

As such we believe it is a great step forward for the RR and LP camps,
and has the potential to significantly increase the widespread
acceptance of these approaches to doing scientific work and
development.  It is the authors hope that this work will
ultimately help to increase communication and help developers and
scientists to make their work more accessible.

#+begin_LaTeX
  \bibliographystyle{abbrv}
  \small
  \bibliography{babel}
#+end_LaTeX

* COMMENT publish
a post-export hook for smaller verbatim text
#+begin_src emacs-lisp :results silent
  (setq org-export-latex-listings t)
#+end_src
