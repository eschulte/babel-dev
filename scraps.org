#+TITLE: org-babel examples and tests
#+OPTIONS: num:nil ^:nil
#+STYLE: <link rel="stylesheet"href="data/stylesheet.css"type="text/css">

* tests and examples
** looking at source name exports

#+source: fibonacci
#+begin_src emacs-lisp :var input=0
  (defun fib (n)
    (if (> n 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        1))
  (fib input)
#+end_src

#+results: fibonacci
: 1

now applying our Fibonacci function

#+call: fibonacci(input=5)

#+results: fibonacci(input=5)
: 8

** short shell test

#+begin_src sh
  date
#+end_src

#+results:
: Sun Feb  7 10:17:44 MST 2010

#+tblname: fibs
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs
  echo "$table" |wc
#+end_src

#+results:
: 6      12      24

#+begin_src sh :var table=fibs
  echo "$table"
#+end_src

#+results:
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs :separator --
  echo "$table" | head -1
#+end_src

#+results:
: 1--1

** tables to shell scripts ideas

#+tblname: sec
| Hello | World |


1) allowing the user to specify a separator with a header argument as
   follows
   #+begin_src sh :var table=sec :separator ,
     cat <<EOF
     $table
     EOF
   #+end_src
   
   which would result in something like

   : "Hello, World"

2) writing the table to a tab or comma separated file and then
   replacing =$table= in the source block body with the path to the
   file name, s.t. something like
   
   #+begin_src sh :var table=data
     wc $table
   #+end_src

   would return reasonable results

** tangling w/o comments and shebang
   :PROPERTIES:
   :tangle:   yes
   :END:

#+begin_src emacs-lisp :comments no :shebang (identity my-shebang)
  (message "I should have no comments")
#+end_src

#+begin_src emacs-lisp :comments no
  (setq my-shebang "poop")
#+end_src

#+results:
: poop

#+begin_src ruby :shebang #!/usr/bin/ruby
  puts :nonstandard_shebang
#+end_src

** exporting to a file
   :PROPERTIES:
   :EXPORT_FILE_NAME: simple
   :EXPORT_TITLE: testing file export
   :END:

this is the contents

and a block
#+begin_src clojure
  (println "is a nice lisp")
#+end_src

ah, it works!

** ditaa blocks

#+begin_src ditaa :file communication.png :cache yes
  -------------
#+end_src

#+results[4fbfc78b37abd8a788958d28a7335445e6042c96]:
[[file:communication.png]]

** babel block overwrite

The first block overwrites
#+begin_src clojure
  (def overwriter "I'll show up everywhere")
#+end_src

this second block
#+begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
#+end_src

** load to session
#+begin_src clojure :session asm-gp
  (in-ns 'asm-gp)
#+end_src

#+begin_src ruby :session
  puts :eric
#+end_src

#+begin_src python :session
  5 + 1 
#+end_src

#+begin_src R :session
  6 + 1
#+end_src

#+begin_src sh :session
  date
#+end_src

#+begin_src ocaml :session
  eric
#+end_src

#+begin_src gnuplot :session
  plot sin(x)
#+end_src

** links

can LaTeX link itself to the middle of a paragraph with a simple
inline link like <<keystone>> if not then we would probably need to
wrap source-code blocks in figures to make them referable.

how about a link back to [[keystone]]

The above appears to work in LaTeX, but not in HTML.

** fancier export

#+source: square
#+begin_src emacs-lisp :var input=1
  (* input input)
#+end_src

** exporting org-source

#+begin_src org
  ,lets see how this org-mode code exports to html
  
  ,is this [[link]] blue?
  
  ,#+begin_src emacs-lisp
  ,  (+ 1 2)
  ,#+end_src
#+end_src

** exporting and caching
#+begin_src ditaa :file data/example.png :exports none
    +------------------+
    |  ditaa example   |
    |                  |
    |                  |
    +------------------+
#+end_src

#+results:
[[file:data/example.png]]

** no noweb by default

#+srcname: sample
#+begin_src emacs-lisp 
  (message "sample")
#+end_src

#+begin_src emacs-lisp :noweb no
  <<sample>>
#+end_src

#+results:
: sample

** looking at double quotes

#+tblname: double-quote-test-input
| test | this | 8 | 9 |

#+srcname: double-quote-test-output
#+begin_src python :var data=double-quote-test-input
  return data
#+end_src

#+results: double-quote-test-output
| test | this | 8 | 9 |

** quoted session name

#+begin_src sh :session "eric"
  echo 'name-me'
#+end_src

#+results:
: name-me

** eval-buffer
#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+results:
: 3

#+begin_src emacs-lisp
  (+ 3 4)
#+end_src

#+results:
: 7

** gnuplot variable expansion

#+source: simple-function
#+begin_src emacs-lisp
  "sin(x)"
#+end_src

#+begin_src gnuplot :var fun=simple-function
  plot $fun
#+end_src

** debug hints
from mailing list

- edebug-defun: (in emacs-lisp mode, C-u C-M-x) will mark the function
  so that when it is called, the interpreter stops and you can then
  single-step through it with <SPACE>. At each point, you can press
  "e" and evaluate variables (actually arbitrary expressions).
- Insert a strategically placed (debug) call and then call the
  function.  If/when the debug call is executed, you are dropped into
  the debugger and you can then evaluate arbitrary expressions.

** sql exports to latex
example from email list
*** ECM

   - faire un script Bash (et =isql=) envoyant un /listing/ de stagiaires;

#+srcname: envoi-stg
   #+begin_src sql
       DECLARE @dateFmtStyleIn int; SET @dateFmtStyleIn = 120 -- ODBC canonical
       DECLARE @dateFmtStyleOut int; SET @dateFmtStyleOut = 103 -- French dd/mm/yyyy

       DECLARE @firstDayOfThisMonth smalldatetime
       SET @firstDayOfThisMonth = CONVERT(smalldatetime,
                                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                                          + '01' + ' 00:00:00',
                                          @dateFmtStyleIn)

       DECLARE @now smalldatetime
       SET @now = CONVERT(smalldatetime,
                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                          + CAST(DAY(GETDATE()) AS char(2)) + ' '
                          + CAST(DATEPART(hh, GETDATE()) AS char(2)) + ':'
                          + CAST(DATEPART(mi, GETDATE()) AS char(2)) + ':'
                          + '00',
                          @dateFmtStyleIn)

       SELECT pfiID
       FROM dossier
#+end_src

** whitespace/newline results issues

#+begin_src sh
  echo output
#+end_src

This
#+begin_src sh
  echo output
#+end_src
text here

results in

t#+results:
: output
ext here

#+begin_src emacs-lisp
  (+ 1 1)
#+end_src

#+results:
: 2
** sh with sessions

#+begin_src sh :session eric
  cd ~/Desktop
#+end_src

#+begin_src sh :session eric
  cd ~/Desktop/clj/
  ls *.clj
#+end_src

#+results:
| "ants.clj" | "" | "concurrent.clj" | "" | "hello.clj" | "" | "spell-checker.clj" |

** testing srcname aliases

#+source: two
#+begin_src emacs-lisp
  2
#+end_src

#+begin_src emacs-lisp :var input=two
  (+ input 1)
#+end_src

#+results[1ec6c8d3de6aaeac7b2720f1d801402e762875ea]:
: 3

** hiding results
#+begin_src emacs-lisp
  (mapcar (lambda (el) (list el)) (number-sequence 0 20))
#+end_src

#+results:
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |

** elisp references

#+begin_src emacs-lisp :results silent
   (setq first 10)
#+end_src

#+srcname: resolve(name=nil)
#+begin_src emacs-lisp :results silent
  (eval (intern name))
#+end_src

#+begin_src python :var a=resolve(name="first")
  return a + 10
#+end_src

** elisp variables

#+begin_src ditaa :file (format "%d.png" 45)
      +-----------+
      |           |
      |           |
      |           |
      |           |
      +-----------+
#+end_src

#+results:
[[file:45.png]]
** haskell and tables
#+begin_src haskell
  sumListCond :: Int -> Int -> [Int] -> Int
  sumListCond l n xs
      | foldl (+) 0 (take l xs) <= n = sumListCond (l + 1) n xs
      | otherwise = foldl (+) 0 (take (l - 1) xs)
#+end_src
#+begin_src oz
  
#+end_src

** latex pngs
$x \mapsto y$

*** Theorem
$|consts(t)| \leq sizes(t)$

- by induction on the structure of t
- base cases are $t \in [true, false, 0]$: 
  - $|consts(t)| = |[t]| = 1 = size(t)$
- inductive size
  - $t \in [succ(t_1), pred(t_1), iszero(t_1)]$:
    - $|consts(t)| = |consts(t_1)| = |[t]| \leq size(t_1) < size(t)$
  - $t = if\, t_1 \, then \, t_2 \, else t_3$
    - $|consts(t)| = |consts(t_1) \cup consts(t_1) \cup consts(t_1)|$
    - $\leq |consts(t_1)| + |consts(t_1)| + |consts(t_1)|$
    - $\leq size(t_1) + size(t_1) + size(t_1)$
    - $< size(t)$

** indexing into gnuplot

#+tblname: squares
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |

#+begin_src gnuplot :var data=squares :results silent
plot data using 1:2 with lines
#+end_src

#+tblname: squares-with-sum
|  1 |  1 |
|  2 |  4 |
|  3 |  9 |
|  4 | 16 |
|  5 | 25 |
|  6 | 36 |
|----+----|
| 21 | 91 |

#+begin_src gnuplot :var data=squares-with-sum[0:-3] :results silent
  plot data using 1:2 with lines
#+end_src

** multiple arguments

#+begin_src emacs-lisp :var first=9 :var second=10
  (+ first second)
#+end_src

#+resname:
: 19

** indexing into results

#+tblname: indexable-table
| eric    |
| michael |
| schulte |
| is      |
| my      |
| name    |

#+begin_src emacs-lisp :var data=indexable-table[2:4]
   data
#+end_src

#+results:
| "schulte" |
| "is"      |
| "my"      |

#+tblname: multidimensional-indexing
| 1 |  2 |
| 3 |  4 |
| 5 |  6 |
| 7 |  8 |
| 9 | 10 |

#+begin_src emacs-lisp :var data=multidimensional-indexing[0:-2]
   data
#+end_src

#+resname:
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
| 7 | 8 |

** cached results
#+begin_src emacs-lisp :cache yes
   (setq org-babel-default-header-args '((:session . "none")
                                         (:results . "replace")
                                         (:exports . "code")(:cache)))
#+end_src

#+results[937269632ae5b5eee5c93f9eb50e0bc55e34520d]:
| (:session . none) | (:results . replace) | (:exports . code) | (:cache) |

#+srcname: eric-schulte
#+begin_src emacs-lisp :cache yes
   (+ 5 7 1)
#+end_src

#+results[005b04829608b3d22b61686e90309af3a9a6fe7c]: eric-schulte
: 13

#+begin_src ditaa :file caching-example.png
    +--------------------+
    |                    |     +-----------+
    |                    |     |           |
    |                    |     |           |
    |      +----+        |     |           |
    |      |    |        |     +-----------+
    |      +----+        |
    |                    |
    +--------------------+
#+end_src

#+results[fd11ddbfd00f6038e6e37db71ddaf43d65b0e200]:
[[file:caching-example.png]]

** switches and references

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

** unresolved noweb references

#+begin_src emacs-lisp :results silent
  (setq org-babel-noweb-error-langs '("ruby"))
#+end_src

#+srcname: i-have-a-name
#+begin_src ruby 
  1 + 2
#+end_src


#+begin_src ruby :noweb
  <<i-have-a-name>> + 3
#+end_src

#+resname:
: 6

** clojure
#+begin_src clojure :results silent
  (list 8 9)
#+end_src

** reference parts of tables

#+TBLNAME: squares
|  1 |   1 |
|  2 |   4 |
|  3 |   9 |
|  4 |  16 |
|  5 |  25 |
|  6 |  36 |
|  7 |  49 |
|  8 |  64 |
|  9 |  81 |
| 10 | 100 |
| 11 | 121 |
| 12 | 144 |
| 13 | 169 |
| 14 | 196 |
| 15 | 225 |
| 16 | 256 |
| 17 | 289 |
| 18 | 324 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=squares
set title "Implementing Gnuplot"
plot data using 1:2 with lines
#+end_src

** results switches
#+begin_src ruby :results output :results_switches -n
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example -n

-
--
---
----
-----
------
-------
--------
---------
#+end_example

#+begin_src ruby :results output
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example
  -
  --
  ---
  ----
  -----
  ------
  -------
  --------
  ---------
#+end_example

** xml and n3

introduce org-babel to =xml= and =n3=
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

** noweb referernces

#+srcname: noweb-example
#+begin_src ruby 
  a = 28
#+end_src

#+begin_src ruby :noweb
  # <<noweb-example>>
  a + 4
#+end_src

#+resname:
: 32

** =pp= results
*** python
#+begin_src python :results pp :session
  ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']
#+end_src

#+resname:
: ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']

*** ruby
#+begin_src ruby :results pp
  class Schulte
    attr_accessor :name, :age
  end
  
  eric = Schulte.new
  eric.name = "eric"
  eric.age = 27
  
  eric
#+end_src

#+resname:


#+begin_src ruby :results pp
  a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
  a
#+end_src

#+resname:
#+begin_example
[1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3]
#+end_example

** empty =output= results for emacs-lisp
#+begin_src emacs-lisp :results output
   8
#+end_src

#+resname:

** =:table= results param
#+begin_src emacs-lisp :results table
  8
#+end_src

#+resname:
| 8 |

** code results
*** emacs lisp
#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (lambda (item) (+ item el))) '(1 2 3 4 5))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
((lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el)))
#+END_SRC

#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (* el el)) '(1 2 3 89))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
(1 4 9 7921)
#+END_SRC

*** ruby

#+begin_src ruby :results code
  [1, 2, 33, 4].map{|n| "the number #{n}"}
#+end_src

#+resname:
#+BEGIN_SRC ruby
  ["the number 1", "the number 2", "the number 33", "the number 4"]
#+END_SRC

#+begin_src ruby :session :results code 
  [1, 2, 33, 4].map{|n| n + 10 }
#+end_src

#+resname:
#+BEGIN_SRC ruby
[11, 12, 43, 14]
#+END_SRC

*** python

#+begin_src python :results code
  ['one', 'two', 'three']
#+end_src

#+resname:
#+BEGIN_SRC python
['one', 'two', 'three']
#+END_SRC

#+begin_src python :results code
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

#+begin_src python :session :results code 
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

** indentation

#+begin_src python
          9
#+end_src

** persistent python
#+begin_src python :session :results silent
  import types
#+end_src

#+begin_src python :session
  types.FunctionType
#+end_src

#+resname:
: function

*** more persistent python
    :PROPERTIES:
    :session:  default
    :END:

#+begin_src python :results silent
  import types
#+end_src

#+begin_src python
  types.FunctionType
#+end_src

#+resname:
: function

** quoted latex

The following latex isn't exported correctly

#+begin_latex
  \begin{code}
  data BTree = Leaf a
             | Node Tree Tree
  \end{code}
#+end_latex

#+begin_src haskell
  data BTree = Leaf a
             | Node Tree Tree
#+end_src

** pretty print

#+begin_src emacs-lisp :results scalar
  '(1 2 3 4)
#+end_src

** simple scalar

#+begin_src emacs-lisp
  (+ 1 3)
#+end_src

#+resname:
: 4

** lua export

#+srcname: determine the neighbors of the segments that the bisector hits
#+begin_src lua :tangle no :exports code
  local s1, s2 = intersecting_segs[1], intersecting_segs[2]
  local n1 = table_find_segment(cell.neighbors, s1)
  local n2 = table_find_segment(cell.neighbors, s2)
#+end_src

I got:
#+begin_example
\lstset{language=lua}
\begin{lstlisting}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{lstlisting}
#+end_example

Emacs -Q got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

Emacs -Q + Org-babel got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

** simple R

#+begin_src R :session R
8
#+end_src

#+resname:
: 8

** changing source name

#+srcname: emacs-nine
#+begin_src emacs-lisp
  8
#+end_src

#+resname: emacs-nine
: 8

#+resname: emacs-eight
: 8

** advanced table
   | DATA             | WHAT       | WHERE       | HOW MUCH |
   |------------------+------------+-------------+----------|
   | [2009-09-25 Fri] |            |             |    28.95 |
   |------------------+------------+-------------+----------|
   |                  | food       | supermarket |     7.85 |
   |                  | ticket bus |             |      2.3 |
   |                  | tea + ice  | ice uno     |      4.4 |
   |                  | ticket     |             |     14.4 |
   |------------------+------------+-------------+----------|
   | [2009-09-26 Sat] |            |             |       41 |

#+begin_src emacs-lisp
  (let ((total 0) (responding t) purchases)
    (while responding
      (setq purchases
            (cons
             (list ""
                   (read-from-minibuffer "What: ")
                   (read-from-minibuffer "Where: ")
                   (read-minibuffer "How Much: "))
             purchases))
      (setq responding (y-or-n-p "more? ")))
    (append 
     purchases
     (list
      (list
       (format-time-string "%Y-%m-%d" (current-time))
       "" "" (progn
               (mapc (lambda (purchase)
                       (setq total (+ total (fourth purchase))))
                     purchases)
               total)))))
#+end_src

#+resname:
| ""           | "fish and chips" | "diner"  |  9.78 |
| ""           | "food"           | "subway" |  5.45 |
| "2009-09-29" | ""               | ""       | 15.23 |

** haskell
#+begin_src haskell
  powerSet :: [a] -> [[a]]
  powerSet = foldr (\ x ps -> map (\ y -> x : y) ps ++ ps ) [[]]
#+end_src

#+begin_src haskell
  powerSet [1, 2, 3]
#+end_src

** yasnippet
** indented
   #+begin_src emacs-lisp
     (message "I ran!!")   
   #+end_src

#+resname:
: I ran!!

** dynamic table
#+TBLNAME: todays-clock
#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
Clock summary at [2009-09-15 Tue 08:51], for Tuesday, September 15, 2009.

| L | Headline     | Time   |      |
|---+--------------+--------+------|
|   | *Total time* | *1:10* |      |
|---+--------------+--------+------|
| 1 | [[file:/Users/eschulte/Desktop/test.org::top][top]]          | 1:10   |    1 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]     |        | 1:00 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::later][later]]        |        | 0:10 |
#+END: clocktable

#+begin_src emacs-lisp :var data=todays-clock(1,1)
(message "table is %S" data)
#+end_src

#+resname:
: table is (("L" "Headline" "Time" "") hline ("" "*Total time*" "*1:10*" "") hline (1 "[[file:/Users/eschulte/Desktop/test.org::top][top]]" "1:10" 1) (2 "[[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]" "" "1:00") (2 "[[file:/Users/eschulte/Desktop/test.org::later][later]]" "" "0:10"))

#+begin_src R :session R-pie-example :var times=todays-clock :results silent
pie(times[2:length(times),4], labels = times[2:length(times),2])
#+end_src

** show all
   CLOCK: [2009-09-15 Tue 07:51]--[2009-09-15 Tue 08:51] =>  1:00
   :PROPERTIES:
   :exports:  both
   :END:

#+begin_src ditaa :file blue.png
   +----------------------+
   |                      |
   |                      |
   |          +-----------+
   |          |           |
   |          |           |
   |          |           |
   |          +-----------+
   |                      |
   +----------------------+
#+end_src
** later
   CLOCK: [2009-09-15 Tue 09:41]--[2009-09-15 Tue 09:51] =>  0:10
stuff here

** and then more
and more stuffs here
** asymptote

#+begin_src asymptote :file asymptote-test.png :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return 1+cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(a,0)$",(1,0),N);
  dot("$(2a,0)$",(2,0),N+E);
#+end_src

#+resname:
[[file:asymptote-test.png]]

** asymptote cosine
#+begin_src asymptote :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  for(int i=0; i < 8; ++i) {
    real j = 0.125 + 0.125*i;
    real h(real t) {return j;};
    path k=polargraph(h, -(acos(j)), acos(j), operator ..);
    draw(k,blue);
  }
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(pi,0)$",(1,0),N);
#+end_src

** gnuplot
#+begin_src gnuplot
plot cosx
#+end_src


* Babel-related code
*** Tangling without org-babel
    Not nice, but if libraries of code are going to be kept in org
    files, then one will sometimes need to load the code without using
    org-babel.
***** Perl script to tangle org-babel input
      This is a first pass; e.g. doesn't deal with :tangle header arg, etc.
#+begin_src perl 
#!/usr/bin/perl

$lang = shift ;
$lang or die "usage: $0 lang < file.org > file.lang\n" ;
$true = 1 ;
$false = 0 ;
$inblock = $false ;

while (<>) {
    if( $inblock ) {
	if( /^[ \t]*#\+end_src/ ) {
	    $inblock = $false ;
	    next ;
	}
	print ;
    }
    else {
	$inblock = /^[ \t]*#\+begin_src[ \t]+$lang/ ;
    }
}
#+end_src
***** R function to load org-babel R code
      This could also be done in pure R, without using an external script.
#+begin_src R 
  source.babel <- function(file)
      source(pipe(paste("org-babel-tangle.pl R", file)))
#+end_src
      
