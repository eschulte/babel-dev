#+TITLE: org-babel examples and tests
#+OPTIONS: num:nil ^:nil
#+STYLE: <link rel="stylesheet"href="data/stylesheet.css"type="text/css">

* tests and examples
** tangle org-mode block
#+source: org-list
#+begin_src org :results latex
  - one
  - two
  - three
#+end_src

#+begin_src emacs-lisp :tangle yes :noweb yes
  "
  <<org-list()>>
  "
#+end_src

** remove results when nil is returned
#+begin_src emacs-lisp
  (progn (+ 1 1) nil)
#+end_src

#+results:

** comparative speed of python evaluation
#+begin_src python :session test
  2+2
#+end_src

#+results:
: 4

#+begin_src python
  return 2+2
#+end_src

#+results:
: 4

#+begin_src python :session test
def add(a,b):
   return a+b
def sub(a,b):
   return a-b
add(sub(10,1),sub(10,2))
#+end_src

#+results:
: org_babel_python_eoe

** customizable comment formats
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-comment-format-beg "{-# LINE %start-line \"%file\" #-}"
        org-babel-tangle-comment-format-end ""
        org-babel-tangle-pad-newline)
#+end_src

#+begin_src haskell :tangle Main.hs
  test = length
  main = print $ test [1,2,3]
#+end_src

I would like the following output in the tangled file Main.hs:

: {-# LINE 4 "Haskell.org" #-}
: test = length
: main = print $ test [1,2,3]

** tangling with full comments
   :PROPERTIES:
   :comments: org
   :tangle:   full-comments.el
   :END:
The top block
#+begin_src emacs-lisp
  (message "first block")
#+end_src

here's some text which won't be tangled

*** subheading
another block
| 1 | first  |
| 2 | second |
#+begin_src emacs-lisp
  (message "second")
#+end_src

and finally a block with a =:noweb= header argument
#+begin_src emacs-lisp :noweb yes
  (progn
    <<tangle-el-the-second>>)
#+end_src

** quoting header args (e.g. :cmdline)
#+begin_src C :cmdline 1 2 3 4 5 :includes <stdio.h>
  int main(int argc, char **argv){
    printf("argv[1] %s\n", argv[1]);
    return 0;
  }
#+end_src

#+results:
: argv[1] 1

** :var (buffer-file-name)
during export (buffer-file-name) will return nil because the temporary
export buffer is not visiting any file.

/file=(vc-working-revision (buffer-file-name))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) "")) :exports results
  echo $file Revision
#+end_src

/file=(vc-working-revision (or (buffer-file-name) org-current-export-file))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) org-current-export-file)) :exports results
  echo $file Revision
#+end_src

** :session evaluation on export
This first block is evaluated but /doesn't/ appear in export.

/:session *R* :exports none/
#+begin_src R :session *R* :exports none
  x <- 8
#+end_src

This second block /does/ appear in export.

#+begin_src R :session *R* :exports results
  x
#+end_src

** ditaa with tilda in path
#+begin_src ditaa :file example.png
    +--------------+
    |              |
    |              |
    |              |
    |              |
    |              |
    +--------------+
#+end_src

** conditional tangling
#+begin_src emacs-lisp :results silent
  (setq tangle-tag "right")
#+end_src

*** first subheading                                                   :left:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "first"
#+end_src

*** second subheading                                                 :right:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "second"
#+end_src

** scheme sessions
#+begin_src scheme :var number=9 :session *scheme* :scheme guile
  (+ number 0)
#+end_src

#+results:
: 9

#+begin_src scheme :var number=9 :session *scheme* :scheme racket
  (+ number 1)
#+end_src

#+results:
: 10

** pulling information from tags                                       :blue:

#+begin_src R :var color=(car (org-get-tags-at (point))) :tangle example.R
  color
#+end_src

#+results:
: blue

** initial scheme support
#+source: numbers
#+begin_src scheme
  (map (lambda (el) (+ el 1)) '(1 2 3))
#+end_src

#+results:
| 2 | 3 | 4 |

#+begin_src scheme :var numbers=numbers
  (map (lambda (el) (- el 1)) numbers)
#+end_src

#+results:
| 1 | 2 | 3 |

** initial javascript support
using node.js

#+begin_src js
  var n = 0;
  n = n+1;
  return n
#+end_src

#+results:
: 1

#+source: cars
#+begin_src js
  var cars = ["Saab","Volvo","BMW"];
  return cars;
#+end_src

#+results: cars
| Saab | Volvo | BMW |

#+begin_src js :var cars=cars
  return cars[0][0];
#+end_src

#+results:
: Saab

#+begin_src js :var cars=cars
  return cars[0].length;
#+end_src

#+results:
: 3

** duplicate results on execute subtree
#+begin_src emacs-lisp :results org :exports results
  "- first
- second
- third
"
#+end_src

#+results:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

** eval for side effect on export
- one plus one
  #+source: one-plus-one
  #+begin_src emacs-lisp :exports none :results silent
    (+ 1 1)
  #+end_src
- plus one is
  #+begin_src emacs-lisp :var two=one-plus-one :exports both
    (+ 1 two)
  #+end_src

** trying out plantuml
setup
#+begin_src emacs-lisp :results silent
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path "~/src/org/contrib/scripts/plantuml.jar")
#+end_src

usage -- sequence diagram
#+begin_src plantuml :file tryout.png
  Alice -> Bob: synchronous call
  Alice ->> Bob: asynchronous call
#+end_src

#+results:
[[file:tryout.png]]

** wrapping up raw/org results
#+begin_src emacs-lisp :results org :exports results
  "- first
  - second
  - third
  "
#+end_src

#+results:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

** not caching
   :PROPERTIES:
   :session:  *R*
   :results:  output
   :exports:  both
   :cache:    yes
   :END:

#+begin_src R 
  cat("random result:", runif(1), "\n")
  Sys.sleep(2)
  alarm()
#+end_src 

#+results[b2549fac8a1ec2923ae289d47ce55fb2853dd1de]:
: random result: 0.2799064

#+begin_src R 
  cat("random result:", runif(1), "\n")
  Sys.sleep(2)
  alarm()
#+end_src 

#+results[b2549fac8a1ec2923ae289d47ce55fb2853dd1de]:
: random result: 0.1625634

*** cache on export
do we export cached blocks

#+begin_src emacs-lisp :cache yes :exports results
  (random)
#+end_src

#+results[46632b4fe2e3a23e847953c95adcba58c270b381]:
: 490528137

*** looks like this is a problem with info collection
#+begin_src emacs-lisp :results scalar
  (format "%S" info)
#+end_src

#+results[855d90e6e7aa9cf461dbb7a0a830689c738c8238]:
: ("emacs-lisp" "(format \"%S\" info)
: " ((:cache . "yes") (:colnames . "no") (:comments . "") (:exports . "both") (:hlines . "yes") (:noweb . "no") (:results . "output replace scalar") (:session . "*R*") (:shebang . "") (:tangle . "no")) "" nil nil 0)

** eval and noeval
date, should export both, but won't output results because of presence
of the =:noeval= header argument.
#+begin_src sh :noeval :exports both
  date
#+end_src

should export code, so no need to do anything
#+begin_src sh
  date
#+end_src

should export nothing, and should not query
#+source: this-is-ls
#+begin_src sh :eval query :exports code
  date
#+end_src

should export results, and should trigger query above
#+begin_src emacs-lisp :var ls=this-is-ls :exports results
  ls
#+end_src

** issues with shell evaluation
#+begin_src sh :results silent
  cd ~/src/org/
  make
#+end_src

** org results and replace

#+begin_src emacs-lisp :results org
  "| 1 | 2 |
| 2 | 3 |"
#+end_src

#+results:
| 1 | 2 |
| 2 | 3 |

#+begin_src R
  rnorm(1)
#+end_src

#+begin_src R
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+results:
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

#+begin_src R :colnames yes
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+results:
| V1 | V2 | V3 |
|----+----+----|
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

** ledger example output text
#+results: ledger-stuff
#+begin_example
09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src sh :var stuff=ledger-stuff
  echo "$stuff"
#+end_src

** importing the output of ledger
#+results: ledger-output
#+begin_example 
  09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
  09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
  09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src emacs-lisp :var ledger=ledger-output
  (with-temp-buffer
    (insert ledger)
    (message ledger)
    (org-table-convert-region (point-min) (point-max) 2)
    (org-table-to-lisp))
#+end_src

#+results:
| 09-Aug-21 CHEQUE : 9953055                | Expenses:Unknown | 166.70 EUR  | 166.70 EUR  |
| 09-Sep-17 CHEQUE : 7691785                | Expenses:Unknown | 100.00 EUR  | 266.70 EUR  |
| 09-Oct-16 REMISE CHEQUE N 8686318 001 105 | Expenses:Unknown | -525.00 EUR | -258.30 EUR |

** lob -- writing results out to files
#+source: table
#+begin_src emacs-lisp
  (mapcar
   (lambda (el) (number-sequence el (+ el 3)))
   (number-sequence 0 4))
#+end_src

writes the results out as csv file
#+call: write(data=table, file="~/Desktop/example.csv") :results silent

writes the results out as tab separated file
#+call: write(data=table, file="~/Desktop/example.tsv") :results silent

write the results out as a normal org-mode file
#+call: write(data=table, file="~/Desktop/example.org") :results silent

** lisp

#+begin_src lisp :var n=5
  (mapcar (lambda (el) (* el el)) (append '(1 7 3 4) (list n)))
#+end_src

#+results:
| 1 | 49 | 9 | 16 | 25 |

#+results: short-list
| 1 |
| 2 |
| 3 |

#+begin_src lisp :var lst=short-list :session t
  (+ 1 (length lst))
#+end_src

#+results:
: 4

** comments in R blocks

#+begin_src R :session *R* :results output
  # this is a comment
  x <- rnorm(1)
  # this is another comment
  x
#+end_src

#+results:
: 
: [1] 1.320853

** tangle R and load
  :PROPERTIES:
  :tangle:   to-load.r
  :END:

evaluate this
#+begin_src emacs-lisp :results silent :tangle no
  (setq org-babel-post-tangle-hook nil)
  (add-hook 'org-babel-post-tangle-hook
            (lambda () (ess-load-file (buffer-file-name))))
#+end_src

then tangle

#+begin_src R :comments yes
x <- 10
#+end_src

#+begin_src R
 y <- 9
#+end_src

#+begin_src R :tangle file2.R
 y <- 9
#+end_src

** colnames to specific variables

#+tblname: spec-colnames
| one | two | thee |
|-----+-----+------|
| 1   | 2   | 3    |

#+tblname: nospec-colnames
| three | two | one |
|-------+-----+-----|
|     3 |   2 |   1 |

#+begin_src python :var nospec=nospec-colnames :var spec=spec-colnames :colnames '(spec)
  return nospec
#+end_src

#+results:
| one   | two | thee |
|-------+-----+------|
| three | two | one  |
| 3     | 2   | 1    |

** caption on code block

#+caption: Examples of variable declaration.
#+label: sql-block
#+begin_src sql
SELECT 6*9;
#+end_src

** palendromic primes
Note that because Haskell is funny about what can be typed into the
interpreter, the following should be loaded with
=org-babel-load-in-session=.
#+begin_src haskell
  palendromic_primes = [x | x <- [1..], prime x, palendrome x]
      where
        factors n = [x | x <- [1..floor(sqrt(fromIntegral(n)))], n `mod` x == 0]
        prime n = factors n == [1]
        primes = [x | x <- [2..], prime x]
        palendrome n = show(n) == reverse(show(n))
  
  palendromic_prime_distances = map (\(x,y)-> y-x) neighbors
      where
        neighbors = (zip palendromic_primes (tail palendromic_primes))
#+end_src

#+source: palendromic_prime_distances
#+begin_src haskell
  take 180 (zip [1..] palendromic_prime_distances)
#+end_src

For high-quality png output from gnuplot, the following sequence of
graphing to a =.eps= file, and then converting to a =.png= can be
useful.
#+source: dist-graph
#+begin_src gnuplot :var data=palendromic_prime_distances :file pps.eps
  set term postscript landscape color enhanced
  set log y
  set title "distance between consecutive palendromic primes"
  plot "$data" with fs notitle
#+end_src

The =convert= command is part of the [[http://www.imagemagick.org/script/index.php][imagemagick]] suite.
#+begin_src sh :var input=dist-graph :results file
  convert -depth 300 -rotate 90 $input pps.png
  echo "pps.png"
#+end_src

** input from an example block
#+results: lorem
#+begin_example 
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
  enimad minim veniam, quis nostrud exercitation ullamco laboris nisi
  ut aliquip ex ea commodo consequat. Duis aute irure dolor in
  reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
  pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
  culpa qui officia deserunt mollit anim id est laborum.
#+end_example

#+begin_src emacs-lisp :var lorem=lorem
  (message "%d words in Lorem" (length (split-string lorem)))
#+end_src

#+results:
: 68 words in Lorem

#+results: 1D
| 1 |
| 2 |
| 3 |
| 4 |

#+begin_src emacs-lisp :var lst=1D[:,0]
  lst
#+end_src

#+results:
: 1

** fixing result insertion
needs to replace the results when there is a new hash

*** normal results
#+begin_src sh
  date
#+end_src

#+results:
: Mon Jul 12 22:18:16 PDT 2010

*** unnamed source block results
#+begin_src emacs-lisp :cache yes
  (+ 1 2 3 4)
#+end_src

#+results[16a776d6d139e1d39e99d736536a546df115c2dc]:
: 10

#+begin_src emacs-lisp :cache yes
  (list '(1 2 3) '(4 5 6))
#+end_src

#+results[53f489ed6977857b9945d79d06e575b2cbbebf11]:
| 1 | 2 | 3 |
| 4 | 5 | 6 |

*** named source block results

#+srcname: something-w-table
#+begin_src emacs-lisp
  (sleep-for 2)
  (list '(1 2 3) '(4 5 8))
#+end_src

#+source: something
#+begin_src emacs-lisp :cache yes
  (+ 1 2 3 4 8)
#+end_src

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enimad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut
aliquip ex ea commodo consequat. Duis aute irure dolor in
reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
culpa qui officia deserunt mollit anim id est laborum.

# something else
#+results[d053f6643d9dc52a0e804c15f2a762da73a00a07]: something
: 18

#+attr_latex: width=0.4\textwidth
#+results[5fac69648ab749ef9ee88ea65b3d49d93f3f6cc8]: something-w-table
| 1 | 2 | 3 |
| 4 | 5 | 8 |

** example w/o source name

delete emacs-lisp below for errors
#+begin_src emacs-lisp
  (* (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1))
#+end_src

** limited precision

#+results: anova-example
| Effect | DFn | DFd |             SSn |              SSd |                F |                    p | p<.05 |              pes |
|--------+-----+-----+-----------------+------------------+------------------+----------------------+-------+------------------|
| Days   |   9 | 153 | 166235.12250176 | 151101.038615303 | 18.7026979326383 | 8.99534541600196e-21 | *     | 0.52384550792003 |

#+begin_src emacs-lisp :var tab=anova-example :colnames yes :cache yes
  (mapcar
   (lambda (row)
     (mapcar
      (lambda (cell) (if (numberp cell) (format "%.4f" cell) cell))
      row))
   tab)
#+end_src

#+results[16ac354f1e7a65594bb59e252ab221e6a4b10f80]:
| Effect |    DFn |      DFd |         SSn |         SSd |       F |                    p | p<.05 |    pes |
|--------+--------+----------+-------------+-------------+---------+----------------------+-------+--------|
| Days   | 9.0000 | 153.0000 | 166235.1225 | 151101.0386 | 18.7027 | 8.99534541600196e-21 | *     | 0.5238 |

** export blocks w/o languages
should raise an error

source
#+begin_src emacs-lisp
  ;; this is a comment
  (+ 1 1 1)
#+end_src

broken source
#+begin_src 
  (+ 2 2 2)
#+end_src

example
#+begin_example 
  this is exampled
#+end_example

#+begin_src ruby
  # this is the first
  [1, 2, 3, 4, 5].map{|r| r+1}
#+end_src

** scratch

#+begin_src emacs-lisp :exports results
  (+ 1 1 1 1)
  (setq org-export-babel-evaluate t)
#+end_src

and now for src_emacs-lisp{87} an inline block

looking at paths
#+begin_src emacs-lisp
  (buffer-file-name)
#+end_src

** dot
#+begin_src dot :file models.png :cmdline -Tpng
  digraph data_relationships {
    "data_requirement" [shape=Mrecord, label="{DataRequirement|description\lformat\l}"]
    "data_product" [shape=Mrecord, label="{DataProduct|name\lversion\lpoc\lformat\l}"]
    "data_requirement" -> "data_product"
  }
#+end_src

#+results:
[[file:models.png]]

** Tom found a bug

#+begin_src emacs-lisp :tangle something.el
  (list 1 (+ 2 3))
#+end_src

#+results:
| 1 | 5 |

** python errors
#+begin_src python :session :results value
  [1, [2], 3, 4]
#+end_src

#+results:
| 1 | (2) | 3 | 4 |

#+begin_src ruby :results output :session
  [1, 2, 3, 4, 6].map{|n| puts n}
#+end_src

#+results:
: 1
: 2
: 3
: 4
: 6

#+begin_src python :session :results output
  print 9
#+end_src

#+results: R-with-colnames
| one |
|-----|
| 1   |

#+begin_src R :results output
  "something"
#+end_src

#+results:
: [1] "something"

#+begin_src R :session *R* :results output
  1
  2
  3
  4
#+end_src

#+results:
: [1] 1
: [1] 2
: [1] 3
: [1] 4

#+begin_src perl :results output
  print "8\n";
  print "9\n";
#+end_src

#+results:
: 8
: 9

#+begin_src clojure
  (+ 8 7)
#+end_src

#+results:
: 15

#+begin_src clojure :session *clj*
  (println "eric")
#+end_src

#+results:
: nil

#+begin_src perl :results value
  8
#+end_src

#+results:
: 8

#+begin_src c++ :includes '(<stdio.h> <math.h> <cstdlib> <time.h>)
  printf("eric schulte\n");
#+end_src

#+results:
: eric schulte

#+begin_src sh
  echo 78
#+end_src

#+results:
: 78

** tangle R and load
   :PROPERTIES:
   :tangle:   with-comments.r
   :comments: yes
   :END:

#+begin_src R :tangle no
  z <- 0
#+end_src

#+begin_src R
  x <- 8
#+end_src

#+begin_src R
  y <- 9
#+end_src

#+srcname: i-have-a-name
#+begin_src R 
  x+y+z
#+end_src

** table comment issue
#+BEGIN_changemargin {-4.2cm}{0cm}
  #+TBLNAME: AutresFPNVE
  #+ATTR_LaTeX: align=lrrrrr
  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Total                                    |                      |                 |                |            |    1062.02 |
  | ^ |                                          |                      |                 |                |            |      Total |
  #+tblfm: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+END_changemargin

save me!

#+begin_src org
  ,  #+TBLNAME: AutresFPNVE
  ,  #+ATTR_LaTeX: align=lrrrrr
  ,  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  ,  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  ,  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  ,  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  ,  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Total                                    |                      |                 |                |            |    1062.02 |
  ,  | ^ |                                          |                      |                 |                |            |      Total |
  ,  #+TBLFM: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+end_src

#+begin_example 
#+tblname: example
| 1 | 2 |
#+end_example

** latex literals in export

  #+ATTR_LaTeX: width=\textwidth
  [[./composite-pattern.png]]

** captions

#+caption: I'm not removed from export
#+label: also-not-removed
| A | B |
| 1 | 2 |

** booktabs
#+tblname: months
| num | Abbrev. |
|-----+---------|
|   1 | Jan.    |
|   2 | Feb.    |
|   3 | Mar.    |

#+call: booktabs(table=months, align="r|l") :results latex :exports results

** complex
#+source: raw-data
#+begin_src sh :results scalar
  wget --quiet -qO- "http://ogdi.cloudapp.net/v1/dc/RecreationParks?format=json"
#+end_src

#+source: dc-parks
#+begin_src emacs-lisp :var keys='(ward area) :var data=raw-data
  (mapcar
    (lambda (lis) (mapcar (lambda (key) (cdr (assoc key lis))) keys))
    (cdr (car (with-temp-buffer
                (insert data) (goto-char (point-min))
                (json-read)))))
#+end_src

#+source: dc-parks-metric
#+begin_src ruby :var data=dc-parks
  data.map{|f| [f[0], 2.59 * f[1]]}
#+end_src

#+begin_src R :var parkData=dc-parks-metric :file parks.png :session *R*
  plot(parkData)
  title(main="Park size by Ward")
#+end_src

#+results:
[[file:parks.png]]

** table-label
#+label: bam
| 1 |
| 2 |
| 3 |

** haskell issues

#+begin_src haskell
  length [1, 2]
#+end_src

#+results:
: 2

#+tblname: example-4-haskell
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |

#+begin_src haskell :var this=example-4-haskell
  length this
#+end_src

#+results:
: 7

** possible prefixes

| prefix   | remaining characters |
|----------+----------------------|
| ob-      |                    5 |
| org-b-   |                    2 |
| orgb-    |                    3 |
| org-bbl- |                    0 |
| bbl-     |                    4 |
| babel-   |                    2 |
#+TBLFM: $2='(sbe leftover (prefix $$1))

#+source: leftover
#+begin_src emacs-lisp :var prefix=""
  (-
   ;; length w/o .el
   (- 13 (length ".el"))
   ;; length of prefix
   (length prefix))
#+end_src

** hlines in python

#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+source: echo-table
#+begin_src python :var tab=many-cols :hlines yes :exports both :session
  return tab
#+end_src

#+begin_src emacs-lisp :var table=echo-table :exports none
  (butlast (apply #'append (mapcar (lambda (el) (list el 'hline)) table)))
#+end_src

#+call: echo-table(tab=many-cols)

#+begin_src python :exports results
  return [['foo', 'bar', 'baz'], ["a", "b", "None of the above"], ['1', 2, 3]]
#+end_src

#+begin_src emacs-lisp :exports results
  (message "Exist")
#+end_src

** protecting block bodies
neither of these work as expected

#+begin_src org
  ,#+TITLE: stuff
  
  ,#+begin_src emacs-lisp
  ,  (message "something")
  ,#+end_src
  
  ,more stuffs
  
  ,#+resname: something
  ,: value
  
  ,# and a comment
#+end_src

#+begin_src org
  ,* example org
  
  ,# this is a comment
  ,this is not a comment
#+end_src


#+begin_src org
  ,* escaped org-mode markup
  
  ,this should be exported as is
  ,#+results: escaping-example
  ,: 24
#+end_src


#+begin_html 
<pre>
#comment
#+end_src
</pre>
#+end_html
final

** multiple evals for refs
#+begin_src emacs-lisp
  (setq counter 0)
#+end_src

#+results:
: 0

#+source: counter
#+begin_src emacs-lisp
  (setq counter (+ 1 counter))
  counter
#+end_src

#+begin_src emacs-lisp :var counter_val=counter
  counter_val
#+end_src

#+results:
: 3

** tangling

#+begin_src sh :shebang #!/bin/sh :tangle yes
  date
#+end_src

#+begin_src sh :shebang #!/bin/bash :tangle whoisme :exports both
  echo $USER
#+end_src

#+begin_src emacs-lisp :tangle yes :comments yes
  (message "BAM")
#+end_src

#+begin_src fortran :exports both
  1+8
#+end_src

** cache on export
do we export cached blocks

#+begin_src sh :cache yes :exports results
  date
#+end_src

#+results[06ed73c6d8d022cf9c323d92af885952865add17]:
: Thu Jun 17 07:35:19 PDT 2010

** foo org
   :PROPERTIES:
   :session:  *R*
   :END:
Figure \ref{fig:one} (p. \pageref{fig:one}) is produced by the following code
#+BEGIN_SRC R 
plot(x, y)
abline(out1)
#+END_SRC
Note that =x=, =y=, and =out1= are remembered from the preceding code
chunk.  We don't have to regenerate them.  All code chunks are part of
one R "session".
and more stuff here and then the results
#+attr_latex: width=0.8\textwidth,placement=[p]
#+label: fig:one
#+caption: Scatter Plot with Regression Line
[[file:fig1.pdf]]

** comments not commented

# $some stuff
# some more stuff$ -- I should be a comment line

1) a source block inside of an =enumerate=
   #+source: plotxy
   #+begin_src emacs-lisp :exports results
     (message "I think so")
   #+end_src
   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src
   

   can cause problems

2) how about this one...
** don't eat me!
1) a source block inside of an =enumerate=
   #+begin_src emacs-lisp :exports results
     (list (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry"))
   #+end_src

   #+results:
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |

   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src

   can cause problems

2) source blocks should be able to be on adjacent lines

** simple reference
#+tblname: table-the-first
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src emacs-lisp :var data=table-the-first[1,1]
  data
#+end_src

#+results:
: 5

** exporting with call lines
#+source: rpn-to-alg(alg)
#+begin_src clojure :results output :var alg="00+"
  (def binary-operators '(\+ \- \* \/))
  (def unary-operators '(\s))
  (defn rpn-to-alg [chars stack]
    (if (> (.size chars) 0)
      (let [el (first chars)]
        (if (some #{el} binary-operators)
          (rpn-to-alg (rest chars)
                      (cons
                       (apply str "(" (or (second stack) 1) " " el " " (or (first stack) 1) ")")
                       (rest (rest stack))))
          (if (some #{el} unary-operators)
            (rpn-to-alg (rest chars)
                        (cons
                         (apply str "(" el " " (or (first stack) 1) ")")
                         (rest (rest stack))))
            (rpn-to-alg (rest chars) (cons el stack)))))
      (first stack)))
  (println (apply str (rpn-to-alg (seq alg) '())))
#+end_src

#+results: distributed-best
: 73*x11/+4/++51xxx13*y/++6y5*6/6-+xx+*

#+call: rpn-to-alg(alg=distributed-best)
 
** can't open indented results

   #+begin_src latex :packages '(("" "tikz") ("active,tightpage" "preview")) :file recursion.pdf
     \begin{preview}
     \ovalbox{
     \begin{tikzpicture}
     \node{$n$}
       child {
         node{$\left(\frac{n}{2}\right)^2$}
           child{
             node{$\left(\frac{n}{4}\right)^2$}
             node{$\left(\frac{n}{4}\right)^2$}
           }
         }
       child{
         node{$\left(\frac{n}{2}\right)^2$}
         child{
           node{$\left(\frac{n}{4}\right)^2$}
           node{$\left(\frac{n}{4}\right)^2$}
         }
       };
     \end{tikzpicture}
     }
     \end{preview}
   #+end_src

   #+results:
   [[file:recursion.pdf]]

** indented source-code blocks and indented results

    #+source: time
    #+begin_src emacs-lisp :results append
      ;; (list (list (current-time-string)))
      (current-time-string)
    #+end_src

    #+results: time
    | 1 | 2 | 3 |


        #+call: time() :results prepend

        #+results: time()
        | 1 | 2 | 3 |
        : Thu Jun 10 14:13:21 2010
        : Thu Jun 10 14:13:21 2010
        : : Thu Jun 10 14:13:21 2010
        : : Thu Jun 10 14:13:21 2010
        : : Thu Jun 10 14:13:21 2010
        : nil
        : nil
        : Thu Jun 10 14:11:22 2010
        : Thu Jun 10 14:11:20 2010
        : nil
        : nil
        : Thu Jun 10 14:06:04 2010
        : Thu Jun 10 14:06:03 2010
        : Thu Jun 10 14:05:51 2010
        : Thu Jun 10 14:05:57 2010
        : Thu Jun 10 14:06:00 2010

** not expand inlines in examples

: src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

** indented source names

   #+srcname: i-am-indented
   #+begin_src emacs-lisp 
     (message "i am indented")
   #+end_src

#+results: i-am-indented
: i am indented

#+begin_src emacs-lisp :var output=i-am-indented
  (length output)
#+end_src

#+results:
: 13

  #+results:
  : eric

** updating results "in-situ"

#+results: in-situ
: update me in place please -- Mon Jun  7 16:44:44 2010
: update me in place please -- Mon Jun  7 16:44:43 2010
: update me in place please -- Mon Jun  7 16:44:42 2010
: update me in place please -- Mon Jun  7 16:44:37 2010
: update me in place please -- Mon Jun  7 16:42:14 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:44:59 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:00 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:02 2010

the results should be *above* the block

#+srcname: in-situ
#+begin_src emacs-lisp :results prepend
  (format "update me in place please -- %s"
          (current-time-string))
#+end_src

#+srcname: in-situ
#+begin_src emacs-lisp :results append
  (format "update me in place please (at the bottom) -- %s"
          (current-time-string))
#+end_src

** inhibiting evaluation on export
   :PROPERTIES:
   :noeval:   don't do it
   :END:

#+begin_src clojure :session eric :exports none
  (+ 1 1 1 1)
  (error)
#+end_src

** executing emacs-lisp on export

#+begin_src emacs-lisp
  (error "eric")
#+end_src

** stripping existing results
#+results: trickily-located-somehwere-else
: I shouldn't be exported

Neither of the result strings for the following two code blocks should
be included in the export.  And only one of the bodies should be
included...

#+begin_src emacs-lisp :exports code
  (+ 1 1 1 1)
#+end_src

#+results:
: don't include me in the export!!!!!!!

#+srcname: trickily-located-somehwere-else
#+begin_src emacs-lisp :exports none
  (message "I shouldn't be exported")
#+end_src

** export with existing results

#+begin_src emacs-lisp :exports none :results silent
  '((1 2) (3 4))
#+end_src

#+results:
| 1 | 2 |
| 3 | 4 |

#+begin_src ditaa :file /tmp/eric.png :exports none :results silent
    +---------------+
    |               |
    |               |
    |               |     +-----------------+
    |    Eric       |     |                 |
    |               |     |    Schulte      |
    |               |     |                 |
    |               |     +-----------------+
    +---------------+
#+end_src

#+results:
[[file:/tmp/eric.png]]

** non-empty comint prompt

#+begin_src ruby :session eric
  8 + 9
#+end_src

** unwind-protect with narrowing

I'm not in the subtree

*** I'm in the subtree
#+begin_src emacs-lisp
  (+ 6 "I'm not a number!!")
#+end_src

** commas on tangling test
test comma protection on tangling

#+begin_src emacs-lisp :results silent
  (org-babel-add-interpreter "org")
  (add-to-list 'org-babel-tangle-langs '("org" "org"))
#+end_src

#+begin_src org :tangle commas.org
  ,* org-mode
  ,  :PROPERTIES:
  ,  :CUSTOM_ID: comma-protect
  ,  :END:
  
  ,#+begin_src emacs-lisp
  ,  protected?
  ,#+end_src
#+end_src

#+begin_example 
  ,* this should be
  # commented out
  
  and maybe not this...
#+end_example

** simple table
#+begin_src emacs-lisp
  '((1 2 3) (4 5 6) (7 8 900))
#+end_src

#+results:
| 1 | 2 |   3 |
| 4 | 5 |   6 |
| 7 | 8 | 900 |

** inline expressions
   :PROPERTIES:
   :session:  'default
   :END:

#+begin_src R :exports code :results silent
  x<-4
#+end_src

the sum of 1 and x is equal to src_R{x+1}, now I'll sneakily reset
this value in a hidden inline block src_R[:exports none]{x<-2}, so
it's value is now src_R{x}.

** adding file names to literal values on export

#+results: three
: 9

#+begin_src R :var num=three :exports results
runif(n=num, min=0, max=1)
#+end_src

#+begin_src R :var num=3 :exports results
runif(n=num, min=0, max=1)
#+end_src

** appending tangle
   :PROPERTIES:
   :tangle:   appended.el
   :END:
append all these block

#+begin_src emacs-lisp
  (message "block %d" 1)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 2)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 3)
#+end_src

** visibility affecting execution

*** folding
lets test folding

**** folded
#+begin_src emacs-lisp
  (message "folded1")
#+end_src

#+results:
: folded1

#+begin_src emacs-lisp
  (message "folded2")
#+end_src

#+results:
: folded2
**** unfolded
#+begin_src emacs-lisp
  (message "unfolded1")
#+end_src

#+results:
: unfolded1
#+begin_src emacs-lisp
  (message "unfolded2")
#+end_src

#+results:
: unfolded2

** empty code blocks -- and latex vs. LaTeX
eric
#+begin_src latex
  
#+end_src

michael
#+begin_src LaTeX
  
#+end_src

schulte
#+begin_src emacs-lisp
  (message "error")
#+end_src

** colnames

#+tblname: A
| a | b | c |
|---+---+---|
| d | e | f |
| g | h | i |

#+begin_src python :var tab=A :colnames yes
return [[val + '*' for val in row] for row in tab]
#+end_src

#+results:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

#+tblname: A
| a | b | c |
| d | e | f |
| g | h | i |

#+begin_src ruby :var tab=A :colnames yes
tab.map{|r| r.map{|e| e+"*"} }
#+end_src

#+results:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

** lisps not fully eval'd

#+begin_src emacs-lisp
  (message "one")
  (message "two")
#+end_src

#+results:
: two

#+begin_src clojure :session :default
  (println "one")
  (println "two")
  (+ 1 2)
#+end_src

#+results:
: 3

** tangling org

#+begin_src org :tangle ~/Desktop/test.org
  ,* first
  ,| eric   | me     |
  ,| patton | my dog |
  
  ,* second
  
  ,some more stuff...
  
  ,#+HTML: <b>I bet this is quoted</b>
#+end_src

#+begin_src ruby :tangle ~/Desktop/test.rb
  # this is a comment
  eric.map{|l| puts l}
#+end_src

** colnames mismatched sizes
#+tblname: mismatch-colnames
| a |  b |
|---+----|
| 1 |  8 |
| 2 |  9 |
| 3 | 10 |
| 4 | 11 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2, 3]]
#+end_src

#+results:
| 1 | 2 | 3 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2]]
#+end_src

#+results:
| a | b |
|---+---|
| 1 | 2 |

#+begin_src python :var tab=mismatch-colnames :colnames yes
  return [1,2]
#+end_src

#+results:
| 1 | 2 |

** variable indexing
#+TBLNAME: MyTable
 |   X |  Y |
 |-----+----|
 |   0 |  0 |
 |   1 |  1 |
 |   2 |  4 |
 |   3 |  9 |
 |   4 | 16 |
 |   5 | 25 |
 |-----+----|
 | Sum | 55 |
 #+TBLFM: $2=$1*$1::@8$2=vsum(@2..@-1)

#+begin_src python :var sum=MyTable[2:7,1] :exports none
   return sum
#+end_src

#+results:
| 0 | 1 | 4 | 9 | 16 | 25 |

#+begin_src python :var sum=MyTable[9,1] :exports none
   return sum
#+end_src

#+results:
: 55

#+begin_src gnuplot :var data=MyTable[1:-2] :var sum=MyTable[7,1]
:results silent :exports none
  reset
  set label "Sum: %.0f",sum at graph 0.03, graph 0.93
  plot data with linespoints
#+end_src

** hline processing
#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+tblname: less-cols
| 1 |
|---|
| 2 |
| 3 |

#+tblname: less-cols2
| 1 | 2 | 3 |

#+begin_src emacs-lisp :var tab=many-cols
  (message "%S" tab)
  ;; (remove 'hline tab)
  ;; (flet ((rem-hline (el)
  ;;                   (if (listp el)
  ;;                       (remove nil (mapcar #'rem-hline el))
  ;;                     (if (equal 'hline el) nil el))))
  ;;   (rem-hline tab))
#+end_src

#+begin_src ruby :var tab=less-cols
  tab
#+end_src

#+results:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var one=2
  1 + 2
#+end_src

#+results:
: 3

#+begin_src python :var tab=less-cols
  return tab
#+end_src

#+results:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var tab=less-cols :colnames no
  tab
#+end_src

#+results:
| 1 |
| 2 |
| 3 |

#+begin_src emacs-lisp :var tab=row-and-col-names
   (message "%S" tab)
#+end_src

#+results:
: (("" "c1" "c2" "c3") hline ("r1" 1 4 7) ("r2" 2 5 8) ("r3" 3 6 9))

#+tblname: row-and-col-names
|    | c1 | c2 | c3 |
|----+----+----+----|
| r1 |  1 |  4 |  7 |
| r2 |  2 |  5 |  8 |
| r3 |  3 |  6 |  9 |

functions
#+begin_src emacs-lisp
  (defun org-babel-del-hlines (table)
    "Remove all 'hlines from TABLE."
    (remove 'hline table))
  
  (defun org-babel-get-colnames (table)
    "Return a cons cell, the `car' of which contains the TABLE
        less colnames, and the `cdr' of which contains a list of the
        column names"
    (if (equal 'hline (second table))
        (cons (cddr table) (car table))
      table))
    
  (defun org-babel-get-rownames (table)
    "Return a cons cell, the `car' of which contains the TABLE less
     colnames, and the `cdr' of which contains a list of the column
     names.  Note: this function removes any hlines in TABLE"
    (flet ((trans (table) (apply #'mapcar* #'list table)))
      (let ((table (trans (remove 'hline table))))
        (cons (cdr table) (car table)))))
  
  (defun org-babel-put-colnames (table colnames)
    "Add COLNAMES to TABLE if they exist."
    (if colnames (apply 'list colnames 'hline table) table))
  
  (defun org-babel-put-rownames (table rownames)
    "Add ROWNAMES to TABLE if they exist."
    (if rownames
        (mapcar (lambda (row)
                  (if (listp row)
                      (cons (or (pop rownames) "") row)
                    row)) table)
      table))
#+end_src

** test gnuplot

#+begin_src gnuplot
  plot sin(x), x+5
#+end_src

** evaluate references

#+begin_src emacs-lisp :var var=`(+ 9 ,(- 19 7)) :tangle yes
  (message "var is %S" var)
#+end_src

#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+results:
: 3

#+begin_src ruby
  + 1 2
#+end_src

#+results:
: nil

** tangling and variable resolution
  :PROPERTIES:
  :ID:       18b4f1be-bb1d-49bc-a651-c97406a35bdd
  :tangle:   yes
  :END:

#+source: A
#+begin_src emacs-lisp :eval no :expand yes :var id=(org-entry-get nil "ID" t) :var two=2
  (concat "This is the entry ID: " id)
#+end_src

#+results: A
: This is the entry ID: 18b4f1be-bb1d-49bc-a651-c97406a35bdd

** latex attributes

#+ATTR_LaTeX: width=0.38\textwidth wrap placement={r}{0.4\textwidth}
#+begin_src ditaa :file=scrap.png
  +---------------------------+
  |                           |
  |       latex               |
  |                           |
  |      +------------+       |
  |      |            |       |
  |      |            |       |
  |      |       cBLU |       |
  |      +------------+       |
  |                      cPNK |
  +---------------------------+
#+end_src

** access to variables set in property drawers
   :PROPERTIES:
   :special:  89
   :text: schulte
   :END:

: "(org-entry-get nil "special" t)"

#+begin_src emacs-lisp :var special=(string-to-number (org-entry-get nil "special" t))
  (+ special 1)
#+end_src

#+results:
: 90

#+begin_src emacs-lisp :var special=(org-entry-get nil "text" t)
  special  
#+end_src

#+results:
: schulte

** variables into shell scripts
#+results: into-shell-scripts
| username | guest   |
| password | nothing |

#+begin_src sh :var username=into-shell-scripts[0,0] :var password=into-shell-scripts[1,1] :results output
  echo "$username -p $password"
#+end_src

#+results:
: username -p nothing

#+results: number-into-shell
: 9

#+begin_src sh :var num=number-into-shell
  for i in `seq $num`; do
      echo $i
  done
#+end_src

#+results:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

** results lines for function calls

#+call: fibonacci(input=5) :resname eric

#+results:
: 8

#+begin_src emacs-lisp :var fib=fibonacci(input=5)
  (message "fib(5)=%d" fib)
#+end_src

#+results:
: fib(5)=8

** haskell variables

playing with Haskell

#+results: haskell-stuff
: 9

#+begin_src haskell :var num=haskell-stuff
  num + 1
#+end_src

#+begin_src ruby :var num=haskell-stuff
  num + 1
#+end_src

#+results:
: 10

** list index w/function style name

#+results: function-style-index
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

#+srcname: function-style-indexing(data=function-style-index[1:4,0])
#+begin_src emacs-lisp
  (message "%S" data)
#+end_src

#+results: function-style-indexing
: ((1) (2) (3) (4))

** looking at source name exports

#+source: fibonacci
#+begin_src emacs-lisp :var input=0
  (defun fib (n)
    (if (> n 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        1))
  (fib input)
#+end_src

#+results: fibonacci
: 1

now applying our Fibonacci function

#+call: fibonacci(input=5)

** short shell test

#+begin_src sh
  date
#+end_src

#+results:
: Sun Feb  7 10:17:44 MST 2010

#+tblname: fibs
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs
  echo "$table" |wc
#+end_src

#+results:
: 6      12      24

#+begin_src sh :var table=fibs
  echo "$table"
#+end_src

#+results:
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs :separator --
  echo "$table" | head -1
#+end_src

#+results:
: 1--1

** tables to shell scripts ideas

#+tblname: sec
| Hello | World |


1) allowing the user to specify a separator with a header argument as
   follows
   #+begin_src sh :var table=sec :separator ,
     cat <<EOF
     $table
     EOF
   #+end_src
   
   which would result in something like

   : "Hello, World"

2) writing the table to a tab or comma separated file and then
   replacing =$table= in the source block body with the path to the
   file name, s.t. something like
   
   #+begin_src sh :var table=data
     wc $table
   #+end_src

   would return reasonable results

** tangling w/o comments and shebang
   :PROPERTIES:
   :tangle:   yes
   :END:

#+begin_src emacs-lisp :comments no :shebang (identity my-shebang)
  (message "I should have no comments")
#+end_src

#+begin_src emacs-lisp :comments no
  (setq my-shebang "foo")
#+end_src

#+results:
: foo

#+begin_src ruby :shebang #!/usr/bin/ruby
  puts :nonstandard_shebang
#+end_src

** exporting to a file
   :PROPERTIES:
   :EXPORT_FILE_NAME: simple
   :EXPORT_TITLE: testing file export
   :END:

this is the contents

and a block
#+begin_src clojure
  (println "is a nice lisp")
#+end_src

ah, it works!

** ditaa blocks

#+begin_src ditaa :file communication.png :cache yes
  -------------
#+end_src

#+results[4fbfc78b37abd8a788958d28a7335445e6042c96]:
[[file:communication.png]]

** babel block overwrite

The first block overwrites
#+begin_src clojure
  (def overwriter "I'll show up everywhere")
#+end_src

this second block
#+begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
#+end_src

** load to session
#+begin_src clojure :session asm-gp
  (in-ns 'asm-gp)
#+end_src

#+begin_src ruby :session
  puts :eric
#+end_src

#+begin_src python :session
  5 + 1 
#+end_src

#+begin_src R :session
  6 + 1
#+end_src

#+begin_src sh :session
  date
#+end_src

#+begin_src ocaml :session
  eric
#+end_src

#+begin_src gnuplot :session
  plot sin(x)
#+end_src

** links

can LaTeX link itself to the middle of a paragraph with a simple
inline link like <<keystone>> if not then we would probably need to
wrap source-code blocks in figures to make them referable.

how about a link back to [[keystone]]

The above appears to work in LaTeX, but not in HTML.

** fancier export

#+source: square
#+begin_src emacs-lisp :var input=1
  (* input input)
#+end_src

** exporting org-source

#+begin_src org
  ,lets see how this org-mode code exports to html
  
  ,is this [[link]] blue?
  
  ,#+begin_src emacs-lisp
  ,  (+ 1 2)
  ,#+end_src
#+end_src

** exporting and caching
#+begin_src ditaa :file data/example.png :exports none
    +------------------+
    |  ditaa example   |
    |                  |
    |                  |
    +------------------+
#+end_src

#+results:
[[file:data/example.png]]

** no noweb by default

#+srcname: sample
#+begin_src emacs-lisp 
  (message "sample")
#+end_src

#+begin_src emacs-lisp :noweb no
  <<sample>>
#+end_src

#+results:
: sample

** looking at double quotes

#+tblname: double-quote-test-input
| test | this | 8 | 9 |

#+srcname: double-quote-test-output
#+begin_src python :var data=double-quote-test-input
  return data
#+end_src

#+results: double-quote-test-output
| test | this | 8 | 9 |

** quoted session name

#+begin_src sh :session "eric"
  echo 'name-me'
#+end_src

#+results:
: name-me

** eval-buffer
#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+results:
: 3

#+begin_src emacs-lisp
  (+ 3 4)
#+end_src

#+results:
: 7

** gnuplot variable expansion

#+source: simple-function
#+begin_src emacs-lisp
  "sin(x)"
#+end_src

#+begin_src gnuplot :var fun=simple-function
  plot $fun
#+end_src

** debug hints
from mailing list

- edebug-defun: (in emacs-lisp mode, C-u C-M-x) will mark the function
  so that when it is called, the interpreter stops and you can then
  single-step through it with <SPACE>. At each point, you can press
  "e" and evaluate variables (actually arbitrary expressions).
- Insert a strategically placed (debug) call and then call the
  function.  If/when the debug call is executed, you are dropped into
  the debugger and you can then evaluate arbitrary expressions.

** sql exports to latex
example from email list
*** ECM

   - faire un script Bash (et =isql=) envoyant un /listing/ de stagiaires;

#+srcname: envoi-stg
   #+begin_src sql
       DECLARE @dateFmtStyleIn int; SET @dateFmtStyleIn = 120 -- ODBC canonical
       DECLARE @dateFmtStyleOut int; SET @dateFmtStyleOut = 103 -- French dd/mm/yyyy

       DECLARE @firstDayOfThisMonth smalldatetime
       SET @firstDayOfThisMonth = CONVERT(smalldatetime,
                                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                                          + '01' + ' 00:00:00',
                                          @dateFmtStyleIn)

       DECLARE @now smalldatetime
       SET @now = CONVERT(smalldatetime,
                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                          + CAST(DAY(GETDATE()) AS char(2)) + ' '
                          + CAST(DATEPART(hh, GETDATE()) AS char(2)) + ':'
                          + CAST(DATEPART(mi, GETDATE()) AS char(2)) + ':'
                          + '00',
                          @dateFmtStyleIn)

       SELECT pfiID
       FROM dossier
#+end_src

** whitespace/newline results issues

#+begin_src sh
  echo output
#+end_src

This
#+begin_src sh
  echo output
#+end_src
text here

results in

t#+results:
: output
ext here

#+begin_src emacs-lisp
  (+ 1 1)
#+end_src

#+results:
: 2
** sh with sessions

#+begin_src sh :session eric
  cd ~/Desktop
#+end_src

#+begin_src sh :session eric
  cd ~/Desktop/clj/
  ls *.clj
#+end_src

#+results:
| "ants.clj" | "" | "concurrent.clj" | "" | "hello.clj" | "" | "spell-checker.clj" |

** testing srcname aliases

#+source: two
#+begin_src emacs-lisp
  2
#+end_src

#+begin_src emacs-lisp :var input=two
  (+ input 1)
#+end_src

#+results[1ec6c8d3de6aaeac7b2720f1d801402e762875ea]:
: 3

** hiding results
#+begin_src emacs-lisp
  (mapcar (lambda (el) (list el)) (number-sequence 0 20))
#+end_src

#+results:
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |

** elisp references

#+begin_src emacs-lisp :results silent
   (setq first 10)
#+end_src

#+srcname: resolve(name=nil)
#+begin_src emacs-lisp :results silent
  (eval (intern name))
#+end_src

#+begin_src python :var a=resolve(name="first")
  return a + 10
#+end_src

** elisp variables

#+begin_src ditaa :file (format "%d.png" 45)
      +-----------+
      |           |
      |           |
      |           |
      |           |
      +-----------+
#+end_src

#+results:
[[file:45.png]]
** haskell and tables
#+begin_src haskell
  sumListCond :: Int -> Int -> [Int] -> Int
  sumListCond l n xs
      | foldl (+) 0 (take l xs) <= n = sumListCond (l + 1) n xs
      | otherwise = foldl (+) 0 (take (l - 1) xs)
#+end_src
#+begin_src oz
  
#+end_src

** latex pngs
$x \mapsto y$

*** Theorem
$|consts(t)| \leq sizes(t)$

- by induction on the structure of t
- base cases are $t \in [true, false, 0]$: 
  - $|consts(t)| = |[t]| = 1 = size(t)$
- inductive size
  - $t \in [succ(t_1), pred(t_1), iszero(t_1)]$:
    - $|consts(t)| = |consts(t_1)| = |[t]| \leq size(t_1) < size(t)$
  - $t = if\, t_1 \, then \, t_2 \, else t_3$
    - $|consts(t)| = |consts(t_1) \cup consts(t_1) \cup consts(t_1)|$
    - $\leq |consts(t_1)| + |consts(t_1)| + |consts(t_1)|$
    - $\leq size(t_1) + size(t_1) + size(t_1)$
    - $< size(t)$

** indexing into gnuplot

#+tblname: squares
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |

#+begin_src gnuplot :var data=squares :results silent
plot data using 1:2 with lines
#+end_src

#+tblname: squares-with-sum
|  1 |  1 |
|  2 |  4 |
|  3 |  9 |
|  4 | 16 |
|  5 | 25 |
|  6 | 36 |
|----+----|
| 21 | 91 |

#+begin_src gnuplot :var data=squares-with-sum[0:-3] :results silent
  plot data using 1:2 with lines
#+end_src

** multiple arguments

#+begin_src emacs-lisp :var first=9 :var second=10
  (+ first second)
#+end_src

#+resname:
: 19

** indexing into results

#+tblname: indexable-table
| eric    |
| michael |
| schulte |
| is      |
| my      |
| name    |

#+begin_src emacs-lisp :var data=indexable-table[2:4]
   data
#+end_src

#+results:
| "schulte" |
| "is"      |
| "my"      |

#+tblname: multidimensional-indexing
| 1 |  2 |
| 3 |  4 |
| 5 |  6 |
| 7 |  8 |
| 9 | 10 |

#+begin_src emacs-lisp :var data=multidimensional-indexing[0:-2]
   data
#+end_src

#+resname:
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
| 7 | 8 |

** cached results
#+begin_src emacs-lisp :cache yes
   (setq org-babel-default-header-args '((:session . "none")
                                         (:results . "replace")
                                         (:exports . "code")(:cache)))
#+end_src

#+results[937269632ae5b5eee5c93f9eb50e0bc55e34520d]:
| (:session . none) | (:results . replace) | (:exports . code) | (:cache) |

#+srcname: eric-schulte
#+begin_src emacs-lisp :cache yes
   (+ 5 7 1)
#+end_src

#+results[005b04829608b3d22b61686e90309af3a9a6fe7c]: eric-schulte
: 13

#+begin_src ditaa :file caching-example.png
    +--------------------+
    |                    |     +-----------+
    |                    |     |           |
    |                    |     |           |
    |      +----+        |     |           |
    |      |    |        |     +-----------+
    |      +----+        |
    |                    |
    +--------------------+
#+end_src

#+results[fd11ddbfd00f6038e6e37db71ddaf43d65b0e200]:
[[file:caching-example.png]]

** switches and references

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

** unresolved noweb references

#+begin_src emacs-lisp :results silent
  (setq org-babel-noweb-error-langs '("ruby"))
#+end_src

#+srcname: i-have-a-name
#+begin_src ruby 
  1 + 2
#+end_src


#+begin_src ruby :noweb
  <<i-have-a-name>> + 3
#+end_src

#+resname:
: 6

** clojure
#+begin_src clojure :results silent
  (list 8 9)
#+end_src

** reference parts of tables

#+TBLNAME: squares
|  1 |   1 |
|  2 |   4 |
|  3 |   9 |
|  4 |  16 |
|  5 |  25 |
|  6 |  36 |
|  7 |  49 |
|  8 |  64 |
|  9 |  81 |
| 10 | 100 |
| 11 | 121 |
| 12 | 144 |
| 13 | 169 |
| 14 | 196 |
| 15 | 225 |
| 16 | 256 |
| 17 | 289 |
| 18 | 324 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=squares
set title "Implementing Gnuplot"
plot data using 1:2 with lines
#+end_src

** results switches
#+begin_src ruby :results output :results_switches -n
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example -n

-
--
---
----
-----
------
-------
--------
---------
#+end_example

#+begin_src ruby :results output
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example
  -
  --
  ---
  ----
  -----
  ------
  -------
  --------
  ---------
#+end_example

** xml and n3

introduce org-babel to =xml= and =n3=
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

** noweb referernces

#+srcname: noweb-example
#+begin_src ruby 
  a = 28
#+end_src

#+begin_src ruby :noweb
  # <<noweb-example>>
  a + 4
#+end_src

#+resname:
: 32

** =pp= results
*** python
#+begin_src python :results pp :session
  ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']
#+end_src

#+resname:
: ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']

*** ruby
#+begin_src ruby :results pp
  class Schulte
    attr_accessor :name, :age
  end
  
  eric = Schulte.new
  eric.name = "eric"
  eric.age = 27
  
  eric
#+end_src

#+resname:


#+begin_src ruby :results pp
  a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
  a
#+end_src

#+resname:
#+begin_example
[1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3]
#+end_example

** empty =output= results for emacs-lisp
#+begin_src emacs-lisp :results output
   8
#+end_src

#+resname:

** =:table= results param
#+begin_src emacs-lisp :results table
  8
#+end_src

#+resname:
| 8 |

** code results
*** emacs lisp
#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (lambda (item) (+ item el))) '(1 2 3 4 5))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
((lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el)))
#+END_SRC

#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (* el el)) '(1 2 3 89))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
(1 4 9 7921)
#+END_SRC

*** ruby

#+begin_src ruby :results code
  [1, 2, 33, 4].map{|n| "the number #{n}"}
#+end_src

#+resname:
#+BEGIN_SRC ruby
  ["the number 1", "the number 2", "the number 33", "the number 4"]
#+END_SRC

#+begin_src ruby :session :results code 
  [1, 2, 33, 4].map{|n| n + 10 }
#+end_src

#+resname:
#+BEGIN_SRC ruby
[11, 12, 43, 14]
#+END_SRC

*** python

#+begin_src python :results code
  ['one', 'two', 'three']
#+end_src

#+resname:
#+BEGIN_SRC python
['one', 'two', 'three']
#+END_SRC

#+begin_src python :results code
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

#+begin_src python :session :results code 
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

** indentation

#+begin_src python
          9
#+end_src

** persistent python
#+begin_src python :session :results silent
  import types
#+end_src

#+begin_src python :session
  types.FunctionType
#+end_src

#+resname:
: function

*** more persistent python
    :PROPERTIES:
    :session:  default
    :END:

#+begin_src python :results silent
  import types
#+end_src

#+begin_src python
  types.FunctionType
#+end_src

#+resname:
: function

** quoted latex

The following latex isn't exported correctly

#+begin_latex
  \begin{code}
  data BTree = Leaf a
             | Node Tree Tree
  \end{code}
#+end_latex

#+begin_src haskell
  data BTree = Leaf a
             | Node Tree Tree
#+end_src

** pretty print

#+begin_src emacs-lisp :results scalar
  '(1 2 3 4)
#+end_src

** simple scalar

#+begin_src emacs-lisp
  (+ 1 3)
#+end_src

#+resname:
: 4

** lua export

#+srcname: determine the neighbors of the segments that the bisector hits
#+begin_src lua :tangle no :exports code
  local s1, s2 = intersecting_segs[1], intersecting_segs[2]
  local n1 = table_find_segment(cell.neighbors, s1)
  local n2 = table_find_segment(cell.neighbors, s2)
#+end_src

I got:
#+begin_example
\lstset{language=lua}
\begin{lstlisting}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{lstlisting}
#+end_example

Emacs -Q got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

Emacs -Q + Org-babel got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

** simple R

#+begin_src R :session R
8
#+end_src

#+resname:
: 8

** changing source name

#+srcname: emacs-nine
#+begin_src emacs-lisp
  8
#+end_src

#+resname: emacs-nine
: 8

#+resname: emacs-eight
: 8

** advanced table
   | DATA             | WHAT       | WHERE       | HOW MUCH |
   |------------------+------------+-------------+----------|
   | [2009-09-25 Fri] |            |             |    28.95 |
   |------------------+------------+-------------+----------|
   |                  | food       | supermarket |     7.85 |
   |                  | ticket bus |             |      2.3 |
   |                  | tea + ice  | ice uno     |      4.4 |
   |                  | ticket     |             |     14.4 |
   |------------------+------------+-------------+----------|
   | [2009-09-26 Sat] |            |             |       41 |

#+begin_src emacs-lisp
  (let ((total 0) (responding t) purchases)
    (while responding
      (setq purchases
            (cons
             (list ""
                   (read-from-minibuffer "What: ")
                   (read-from-minibuffer "Where: ")
                   (read-minibuffer "How Much: "))
             purchases))
      (setq responding (y-or-n-p "more? ")))
    (append 
     purchases
     (list
      (list
       (format-time-string "%Y-%m-%d" (current-time))
       "" "" (progn
               (mapc (lambda (purchase)
                       (setq total (+ total (fourth purchase))))
                     purchases)
               total)))))
#+end_src

#+resname:
| ""           | "fish and chips" | "diner"  |  9.78 |
| ""           | "food"           | "subway" |  5.45 |
| "2009-09-29" | ""               | ""       | 15.23 |

** haskell
#+begin_src haskell
  powerSet :: [a] -> [[a]]
  powerSet = foldr (\ x ps -> map (\ y -> x : y) ps ++ ps ) [[]]
#+end_src

#+begin_src haskell
  powerSet [1, 2, 3]
#+end_src

** yasnippet
** indented
   #+begin_src emacs-lisp
     (message "I ran!!")   
   #+end_src

#+resname:
: I ran!!

** dynamic table
#+TBLNAME: todays-clock
#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
Clock summary at [2009-09-15 Tue 08:51], for Tuesday, September 15, 2009.

| L | Headline     | Time   |      |
|---+--------------+--------+------|
|   | *Total time* | *1:10* |      |
|---+--------------+--------+------|
| 1 | [[file:/Users/eschulte/Desktop/test.org::top][top]]          | 1:10   |    1 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]     |        | 1:00 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::later][later]]        |        | 0:10 |
#+END: clocktable

#+begin_src emacs-lisp :var data=todays-clock(1,1)
(message "table is %S" data)
#+end_src

#+resname:
: table is (("L" "Headline" "Time" "") hline ("" "*Total time*" "*1:10*" "") hline (1 "[[file:/Users/eschulte/Desktop/test.org::top][top]]" "1:10" 1) (2 "[[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]" "" "1:00") (2 "[[file:/Users/eschulte/Desktop/test.org::later][later]]" "" "0:10"))

#+begin_src R :session R-pie-example :var times=todays-clock :results silent
pie(times[2:length(times),4], labels = times[2:length(times),2])
#+end_src

** show all
   CLOCK: [2009-09-15 Tue 07:51]--[2009-09-15 Tue 08:51] =>  1:00
   :PROPERTIES:
   :exports:  both
   :END:

#+begin_src ditaa :file blue.png
   +----------------------+
   |                      |
   |                      |
   |          +-----------+
   |          |           |
   |          |           |
   |          |           |
   |          +-----------+
   |                      |
   +----------------------+
#+end_src
** later
   CLOCK: [2009-09-15 Tue 09:41]--[2009-09-15 Tue 09:51] =>  0:10
stuff here

** and then more
and more stuffs here
** asymptote

#+begin_src asymptote :file asymptote-test.png :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return 1+cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(a,0)$",(1,0),N);
  dot("$(2a,0)$",(2,0),N+E);
#+end_src

#+resname:
[[file:asymptote-test.png]]

** asymptote cosine
#+begin_src asymptote :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  for(int i=0; i < 8; ++i) {
    real j = 0.125 + 0.125*i;
    real h(real t) {return j;};
    path k=polargraph(h, -(acos(j)), acos(j), operator ..);
    draw(k,blue);
  }
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(pi,0)$",(1,0),N);
#+end_src

** gnuplot
#+begin_src gnuplot
plot cosx
#+end_src


#+end_src
      
