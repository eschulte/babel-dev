#+TITLE: org-babel examples and tests
#+OPTIONS: num:nil ^:nil
#+STYLE: <link rel="stylesheet"href="data/stylesheet.css"type="text/css">

* tests and examples
** cache on export
do we export cached blocks

#+begin_src sh :cache yes :exports results
  date
#+end_src

#+results[06ed73c6d8d022cf9c323d92af885952865add17]:
: Thu Jun 17 07:35:19 PDT 2010

** foo org
   :PROPERTIES:
   :session:  *R*
   :END:
Figure \ref{fig:one} (p. \pageref{fig:one}) is produced by the following code
#+BEGIN_SRC R 
plot(x, y)
abline(out1)
#+END_SRC
Note that =x=, =y=, and =out1= are remembered from the preceding code
chunk.  We don't have to regenerate them.  All code chunks are part of
one R "session".
and more stuff here and then the results
#+attr_latex: width=0.8\textwidth,placement=[p]
#+label: fig:one
#+caption: Scatter Plot with Regression Line
[[file:fig1.pdf]]

** comments not commented

# $some stuff
# some more stuff$ -- I should be a comment line

1) a source block inside of an =enumerate=
   #+source: plotxy
   #+begin_src emacs-lisp :exports results
     (message "I think so")
   #+end_src
   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src
   

   can cause problems

2) how about this one...
** don't eat me!
1) a source block inside of an =enumerate=
   #+begin_src emacs-lisp :exports results
     (list (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry"))
   #+end_src

   #+results:
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |

   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src

   can cause problems

2) source blocks should be able to be on adjacent lines

** simple reference
#+tblname: table-the-first
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src emacs-lisp :var data=table-the-first[1,1]
  data
#+end_src

#+results:
: 5

** exporting with call lines
#+source: rpn-to-alg(alg)
#+begin_src clojure :results output :var alg="00+"
  (def binary-operators '(\+ \- \* \/))
  (def unary-operators '(\s))
  (defn rpn-to-alg [chars stack]
    (if (> (.size chars) 0)
      (let [el (first chars)]
        (if (some #{el} binary-operators)
          (rpn-to-alg (rest chars)
                      (cons
                       (apply str "(" (or (second stack) 1) " " el " " (or (first stack) 1) ")")
                       (rest (rest stack))))
          (if (some #{el} unary-operators)
            (rpn-to-alg (rest chars)
                        (cons
                         (apply str "(" el " " (or (first stack) 1) ")")
                         (rest (rest stack))))
            (rpn-to-alg (rest chars) (cons el stack)))))
      (first stack)))
  (println (apply str (rpn-to-alg (seq alg) '())))
#+end_src

#+results: distributed-best
: 73*x11/+4/++51xxx13*y/++6y5*6/6-+xx+*

#+call: rpn-to-alg(alg=distributed-best)
 
** can't open indented results

   #+begin_src latex :packages '(("" "tikz") ("active,tightpage" "preview")) :file recursion.pdf
     \begin{preview}
     \ovalbox{
     \begin{tikzpicture}
     \node{$n$}
       child {
         node{$\left(\frac{n}{2}\right)^2$}
           child{
             node{$\left(\frac{n}{4}\right)^2$}
             node{$\left(\frac{n}{4}\right)^2$}
           }
         }
       child{
         node{$\left(\frac{n}{2}\right)^2$}
         child{
           node{$\left(\frac{n}{4}\right)^2$}
           node{$\left(\frac{n}{4}\right)^2$}
         }
       };
     \end{tikzpicture}
     }
     \end{preview}
   #+end_src

   #+results:
   [[file:recursion.pdf]]

** indented source-code blocks and indented results

    #+source: time
    #+begin_src emacs-lisp :results append
      ;; (list (list (current-time-string)))
      (current-time-string)
    #+end_src

    #+results: time
    | 1 | 2 | 3 |


        #+call: time() :results prepend

        #+results: time()
        | 1 | 2 | 3 |
        : Thu Jun 10 14:13:21 2010
        : Thu Jun 10 14:13:21 2010
        : : Thu Jun 10 14:13:21 2010
        : : Thu Jun 10 14:13:21 2010
        : : Thu Jun 10 14:13:21 2010
        : nil
        : nil
        : Thu Jun 10 14:11:22 2010
        : Thu Jun 10 14:11:20 2010
        : nil
        : nil
        : Thu Jun 10 14:06:04 2010
        : Thu Jun 10 14:06:03 2010
        : Thu Jun 10 14:05:51 2010
        : Thu Jun 10 14:05:57 2010
        : Thu Jun 10 14:06:00 2010

** not expand inlines in examples

: src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

** indented source names

   #+srcname: i-am-indented
   #+begin_src emacs-lisp 
     (message "i am indented")
   #+end_src

#+results: i-am-indented
: i am indented

#+begin_src emacs-lisp :var output=i-am-indented
  (length output)
#+end_src

#+results:
: 13

  #+results:
  : eric

** updating results "in-situ"

#+results: in-situ
: update me in place please -- Mon Jun  7 16:44:44 2010
: update me in place please -- Mon Jun  7 16:44:43 2010
: update me in place please -- Mon Jun  7 16:44:42 2010
: update me in place please -- Mon Jun  7 16:44:37 2010
: update me in place please -- Mon Jun  7 16:42:14 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:44:59 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:00 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:02 2010

the results should be *above* the block

#+srcname: in-situ
#+begin_src emacs-lisp :results prepend
  (format "update me in place please -- %s"
          (current-time-string))
#+end_src

#+srcname: in-situ
#+begin_src emacs-lisp :results append
  (format "update me in place please (at the bottom) -- %s"
          (current-time-string))
#+end_src

** inhibiting evaluation on export
   :PROPERTIES:
   :noeval:   don't do it
   :END:

#+begin_src clojure :session eric :exports none
  (+ 1 1 1 1)
  (error)
#+end_src

** executing emacs-lisp on export

#+begin_src emacs-lisp
  (error "eric")
#+end_src

** stripping existing results
#+results: trickily-located-somehwere-else
: I shouldn't be exported

Neither of the result strings for the following two code blocks should
be included in the export.  And only one of the bodies should be
included...

#+begin_src emacs-lisp :exports code
  (+ 1 1 1 1)
#+end_src

#+results:
: don't include me in the export!!!!!!!

#+srcname: trickily-located-somehwere-else
#+begin_src emacs-lisp :exports none
  (message "I shouldn't be exported")
#+end_src

** export with existing results

#+begin_src emacs-lisp :exports none :results silent
  '((1 2) (3 4))
#+end_src

#+results:
| 1 | 2 |
| 3 | 4 |

#+begin_src ditaa :file /tmp/eric.png :exports none :results silent
    +---------------+
    |               |
    |               |
    |               |     +-----------------+
    |    Eric       |     |                 |
    |               |     |    Schulte      |
    |               |     |                 |
    |               |     +-----------------+
    +---------------+
#+end_src

#+results:
[[file:/tmp/eric.png]]

** non-empty comint prompt

#+begin_src ruby :session eric
  8 + 9
#+end_src

** unwind-protect with narrowing

I'm not in the subtree

*** I'm in the subtree
#+begin_src emacs-lisp
  (+ 6 "I'm not a number!!")
#+end_src

** commas on tangling test
test comma protection on tangling

#+begin_src emacs-lisp :results silent
  (org-babel-add-interpreter "org")
  (add-to-list 'org-babel-tangle-langs '("org" "org"))
#+end_src

#+begin_src org :tangle commas.org
  ,* org-mode
  ,  :PROPERTIES:
  ,  :CUSTOM_ID: comma-protect
  ,  :END:
  
  ,#+begin_src emacs-lisp
  ,  protected?
  ,#+end_src
#+end_src

#+begin_example 
  ,* this should be
  # commented out
  
  and maybe not this...
#+end_example

** simple table
#+begin_src emacs-lisp
  '((1 2 3) (4 5 6) (7 8 900))
#+end_src

#+results:
| 1 | 2 |   3 |
| 4 | 5 |   6 |
| 7 | 8 | 900 |

** inline expressions
   :PROPERTIES:
   :session:  'default
   :END:

#+begin_src R :exports code :results silent
  x<-4
#+end_src

the sum of 1 and x is equal to src_R{x+1}, now I'll sneakily reset
this value in a hidden inline block src_R[:exports none]{x<-2}, so
it's value is now src_R{x}.

** adding file names to literal values on export

#+results: three
: 9

#+begin_src R :var num=three :exports results
runif(n=num, min=0, max=1)
#+end_src

#+begin_src R :var num=3 :exports results
runif(n=num, min=0, max=1)
#+end_src

** appending tangle
   :PROPERTIES:
   :tangle:   appended.el
   :END:
append all these block

#+begin_src emacs-lisp
  (message "block %d" 1)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 2)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 3)
#+end_src

** visibility affecting execution

*** folding
lets test folding

**** folded
#+begin_src emacs-lisp
  (message "folded1")
#+end_src

#+results:
: folded1

#+begin_src emacs-lisp
  (message "folded2")
#+end_src

#+results:
: folded2
**** unfolded
#+begin_src emacs-lisp
  (message "unfolded1")
#+end_src

#+results:
: unfolded1
#+begin_src emacs-lisp
  (message "unfolded2")
#+end_src

#+results:
: unfolded2

** empty code blocks -- and latex vs. LaTeX
eric
#+begin_src latex
  
#+end_src

michael
#+begin_src LaTeX
  
#+end_src

schulte
#+begin_src emacs-lisp
  (message "error")
#+end_src

** colnames

#+tblname: A
| a | b | c |
| d | e | f |
| g | h | i |

#+begin_src python :var tab=A :colnames yes
return [[val + '*' for val in row] for row in tab]
#+end_src

#+results:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

#+tblname: A
| a | b | c |
| d | e | f |
| g | h | i |

#+begin_src ruby :var tab=A :colnames yes
tab.map{|r| r.map{|e| e+"*"} }
#+end_src

#+results:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

** lisps not fully eval'd

#+begin_src emacs-lisp
  (message "one")
  (message "two")
#+end_src

#+results:
: two

#+begin_src clojure :session :default
  (println "one")
  (println "two")
  (+ 1 2)
#+end_src

#+results:
: 3

** tangling org

#+begin_src org :tangle ~/Desktop/test.org
  ,* first
  ,| eric   | me     |
  ,| patton | my dog |
  
  ,* second
  
  ,some more stuff...
  
  ,#+HTML: <b>I bet this is quoted</b>
#+end_src

#+begin_src ruby :tangle ~/Desktop/test.rb
  # this is a comment
  eric.map{|l| puts l}
#+end_src

** colnames mismatched sizes
#+tblname: mismatch-colnames
| a |  b |
|---+----|
| 1 |  8 |
| 2 |  9 |
| 3 | 10 |
| 4 | 11 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2, 3]]
#+end_src

#+results:
| 1 | 2 | 3 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2]]
#+end_src

#+results:
| a | b |
|---+---|
| 1 | 2 |

#+begin_src python :var tab=mismatch-colnames :colnames yes
  return [1,2]
#+end_src

#+results:
| 1 | 2 |

** variable indexing
#+TBLNAME: MyTable
 |   X |  Y |
 |-----+----|
 |   0 |  0 |
 |   1 |  1 |
 |   2 |  4 |
 |   3 |  9 |
 |   4 | 16 |
 |   5 | 25 |
 |-----+----|
 | Sum | 55 |
 #+TBLFM: $2=$1*$1::@8$2=vsum(@2..@-1)

#+begin_src python :var sum=MyTable[2:7,1] :exports none
   return sum
#+end_src

#+results:
| 0 | 1 | 4 | 9 | 16 | 25 |

#+begin_src python :var sum=MyTable[9,1] :exports none
   return sum
#+end_src

#+results:
: 55

#+begin_src gnuplot :var data=MyTable[1:-2] :var sum=MyTable[7,1]
:results silent :exports none
  reset
  set label "Sum: %.0f",sum at graph 0.03, graph 0.93
  plot data with linespoints
#+end_src

** hline processing
#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+tblname: less-cols
| 1 |
|---|
| 2 |
| 3 |

#+tblname: less-cols2
| 1 | 2 | 3 |

#+begin_src emacs-lisp :var tab=many-cols
  (message "%S" tab)
  ;; (remove 'hline tab)
  ;; (flet ((rem-hline (el)
  ;;                   (if (listp el)
  ;;                       (remove nil (mapcar #'rem-hline el))
  ;;                     (if (equal 'hline el) nil el))))
  ;;   (rem-hline tab))
#+end_src

#+begin_src ruby :var tab=less-cols
  tab
#+end_src

#+results:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var one=2
  1 + 2
#+end_src

#+results:
: 3

#+begin_src python :var tab=less-cols
  return tab
#+end_src

#+results:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var tab=less-cols :colnames no
  tab
#+end_src

#+results:
| 1 |
| 2 |
| 3 |

#+begin_src emacs-lisp :var tab=row-and-col-names
   (message "%S" tab)
#+end_src

#+results:
: (("" "c1" "c2" "c3") hline ("r1" 1 4 7) ("r2" 2 5 8) ("r3" 3 6 9))

#+tblname: row-and-col-names
|    | c1 | c2 | c3 |
|----+----+----+----|
| r1 |  1 |  4 |  7 |
| r2 |  2 |  5 |  8 |
| r3 |  3 |  6 |  9 |

functions
#+begin_src emacs-lisp
  (defun org-babel-del-hlines (table)
    "Remove all 'hlines from TABLE."
    (remove 'hline table))
  
  (defun org-babel-get-colnames (table)
    "Return a cons cell, the `car' of which contains the TABLE
        less colnames, and the `cdr' of which contains a list of the
        column names"
    (if (equal 'hline (second table))
        (cons (cddr table) (car table))
      table))
    
  (defun org-babel-get-rownames (table)
    "Return a cons cell, the `car' of which contains the TABLE less
     colnames, and the `cdr' of which contains a list of the column
     names.  Note: this function removes any hlines in TABLE"
    (flet ((trans (table) (apply #'mapcar* #'list table)))
      (let ((table (trans (remove 'hline table))))
        (cons (cdr table) (car table)))))
  
  (defun org-babel-put-colnames (table colnames)
    "Add COLNAMES to TABLE if they exist."
    (if colnames (apply 'list colnames 'hline table) table))
  
  (defun org-babel-put-rownames (table rownames)
    "Add ROWNAMES to TABLE if they exist."
    (if rownames
        (mapcar (lambda (row)
                  (if (listp row)
                      (cons (or (pop rownames) "") row)
                    row)) table)
      table))
#+end_src

** test gnuplot

#+begin_src gnuplot
  plot sin(x), x+5
#+end_src

** evaluate references

#+begin_src emacs-lisp :var var=`(+ 9 ,(- 19 7)) :tangle yes
  (message "var is %S" var)
#+end_src

#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+results:
: 3

#+begin_src ruby
  + 1 2
#+end_src

#+results:
: nil

** tangling and variable resolution
  :PROPERTIES:
  :ID:       18b4f1be-bb1d-49bc-a651-c97406a35bdd
  :tangle:   yes
  :END:

#+source: A
#+begin_src emacs-lisp :eval no :expand yes :var id=(org-entry-get nil "ID" t) :var two=2
  (concat "This is the entry ID: " id)
#+end_src

#+results: A
: This is the entry ID: 18b4f1be-bb1d-49bc-a651-c97406a35bdd

** latex attributes

#+ATTR_LaTeX: width=0.38\textwidth wrap placement={r}{0.4\textwidth}
#+begin_src ditaa :file=scrap.png
  +---------------------------+
  |                           |
  |       latex               |
  |                           |
  |      +------------+       |
  |      |            |       |
  |      |            |       |
  |      |       cBLU |       |
  |      +------------+       |
  |                      cPNK |
  +---------------------------+
#+end_src

** access to variables set in property drawers
   :PROPERTIES:
   :special:  89
   :text: schulte
   :END:

: "(org-entry-get nil "special" t)"

#+begin_src emacs-lisp :var special=(string-to-number (org-entry-get nil "special" t))
  (+ special 1)
#+end_src

#+results:
: 90

#+begin_src emacs-lisp :var special=(org-entry-get nil "text" t)
  special  
#+end_src

#+results:
: schulte

** variables into shell scripts
#+results: into-shell-scripts
| username | guest   |
| password | nothing |

#+begin_src sh :var username=into-shell-scripts[0,0] :var password=into-shell-scripts[1,1] :results output
  echo "$username -p $password"
#+end_src

#+results:
: username -p nothing

#+results: number-into-shell
: 9

#+begin_src sh :var num=number-into-shell
  for i in `seq $num`; do
      echo $i
  done
#+end_src

#+results:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

** results lines for function calls

#+call: fibonacci(input=5) :resname eric

#+results:
: 8

#+begin_src emacs-lisp :var fib=fibonacci(input=5)
  (message "fib(5)=%d" fib)
#+end_src

#+results:
: fib(5)=8

** haskell variables

playing with Haskell

#+results: haskell-stuff
: 9

#+begin_src haskell :var num=haskell-stuff
  num + 1
#+end_src

#+begin_src ruby :var num=haskell-stuff
  num + 1
#+end_src

#+results:
: 10

** list index w/function style name

#+results: function-style-index
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

#+srcname: function-style-indexing(data=function-style-index[1:4,0])
#+begin_src emacs-lisp
  (message "%S" data)
#+end_src

#+results: function-style-indexing
: ((1) (2) (3) (4))

** looking at source name exports

#+source: fibonacci
#+begin_src emacs-lisp :var input=0
  (defun fib (n)
    (if (> n 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        1))
  (fib input)
#+end_src

#+results: fibonacci
: 1

now applying our Fibonacci function

#+call: fibonacci(input=5)

** short shell test

#+begin_src sh
  date
#+end_src

#+results:
: Sun Feb  7 10:17:44 MST 2010

#+tblname: fibs
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs
  echo "$table" |wc
#+end_src

#+results:
: 6      12      24

#+begin_src sh :var table=fibs
  echo "$table"
#+end_src

#+results:
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs :separator --
  echo "$table" | head -1
#+end_src

#+results:
: 1--1

** tables to shell scripts ideas

#+tblname: sec
| Hello | World |


1) allowing the user to specify a separator with a header argument as
   follows
   #+begin_src sh :var table=sec :separator ,
     cat <<EOF
     $table
     EOF
   #+end_src
   
   which would result in something like

   : "Hello, World"

2) writing the table to a tab or comma separated file and then
   replacing =$table= in the source block body with the path to the
   file name, s.t. something like
   
   #+begin_src sh :var table=data
     wc $table
   #+end_src

   would return reasonable results

** tangling w/o comments and shebang
   :PROPERTIES:
   :tangle:   yes
   :END:

#+begin_src emacs-lisp :comments no :shebang (identity my-shebang)
  (message "I should have no comments")
#+end_src

#+begin_src emacs-lisp :comments no
  (setq my-shebang "poop")
#+end_src

#+results:
: poop

#+begin_src ruby :shebang #!/usr/bin/ruby
  puts :nonstandard_shebang
#+end_src

** exporting to a file
   :PROPERTIES:
   :EXPORT_FILE_NAME: simple
   :EXPORT_TITLE: testing file export
   :END:

this is the contents

and a block
#+begin_src clojure
  (println "is a nice lisp")
#+end_src

ah, it works!

** ditaa blocks

#+begin_src ditaa :file communication.png :cache yes
  -------------
#+end_src

#+results[4fbfc78b37abd8a788958d28a7335445e6042c96]:
[[file:communication.png]]

** babel block overwrite

The first block overwrites
#+begin_src clojure
  (def overwriter "I'll show up everywhere")
#+end_src

this second block
#+begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
#+end_src

** load to session
#+begin_src clojure :session asm-gp
  (in-ns 'asm-gp)
#+end_src

#+begin_src ruby :session
  puts :eric
#+end_src

#+begin_src python :session
  5 + 1 
#+end_src

#+begin_src R :session
  6 + 1
#+end_src

#+begin_src sh :session
  date
#+end_src

#+begin_src ocaml :session
  eric
#+end_src

#+begin_src gnuplot :session
  plot sin(x)
#+end_src

** links

can LaTeX link itself to the middle of a paragraph with a simple
inline link like <<keystone>> if not then we would probably need to
wrap source-code blocks in figures to make them referable.

how about a link back to [[keystone]]

The above appears to work in LaTeX, but not in HTML.

** fancier export

#+source: square
#+begin_src emacs-lisp :var input=1
  (* input input)
#+end_src

** exporting org-source

#+begin_src org
  ,lets see how this org-mode code exports to html
  
  ,is this [[link]] blue?
  
  ,#+begin_src emacs-lisp
  ,  (+ 1 2)
  ,#+end_src
#+end_src

** exporting and caching
#+begin_src ditaa :file data/example.png :exports none
    +------------------+
    |  ditaa example   |
    |                  |
    |                  |
    +------------------+
#+end_src

#+results:
[[file:data/example.png]]

** no noweb by default

#+srcname: sample
#+begin_src emacs-lisp 
  (message "sample")
#+end_src

#+begin_src emacs-lisp :noweb no
  <<sample>>
#+end_src

#+results:
: sample

** looking at double quotes

#+tblname: double-quote-test-input
| test | this | 8 | 9 |

#+srcname: double-quote-test-output
#+begin_src python :var data=double-quote-test-input
  return data
#+end_src

#+results: double-quote-test-output
| test | this | 8 | 9 |

** quoted session name

#+begin_src sh :session "eric"
  echo 'name-me'
#+end_src

#+results:
: name-me

** eval-buffer
#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+results:
: 3

#+begin_src emacs-lisp
  (+ 3 4)
#+end_src

#+results:
: 7

** gnuplot variable expansion

#+source: simple-function
#+begin_src emacs-lisp
  "sin(x)"
#+end_src

#+begin_src gnuplot :var fun=simple-function
  plot $fun
#+end_src

** debug hints
from mailing list

- edebug-defun: (in emacs-lisp mode, C-u C-M-x) will mark the function
  so that when it is called, the interpreter stops and you can then
  single-step through it with <SPACE>. At each point, you can press
  "e" and evaluate variables (actually arbitrary expressions).
- Insert a strategically placed (debug) call and then call the
  function.  If/when the debug call is executed, you are dropped into
  the debugger and you can then evaluate arbitrary expressions.

** sql exports to latex
example from email list
*** ECM

   - faire un script Bash (et =isql=) envoyant un /listing/ de stagiaires;

#+srcname: envoi-stg
   #+begin_src sql
       DECLARE @dateFmtStyleIn int; SET @dateFmtStyleIn = 120 -- ODBC canonical
       DECLARE @dateFmtStyleOut int; SET @dateFmtStyleOut = 103 -- French dd/mm/yyyy

       DECLARE @firstDayOfThisMonth smalldatetime
       SET @firstDayOfThisMonth = CONVERT(smalldatetime,
                                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                                          + '01' + ' 00:00:00',
                                          @dateFmtStyleIn)

       DECLARE @now smalldatetime
       SET @now = CONVERT(smalldatetime,
                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                          + CAST(DAY(GETDATE()) AS char(2)) + ' '
                          + CAST(DATEPART(hh, GETDATE()) AS char(2)) + ':'
                          + CAST(DATEPART(mi, GETDATE()) AS char(2)) + ':'
                          + '00',
                          @dateFmtStyleIn)

       SELECT pfiID
       FROM dossier
#+end_src

** whitespace/newline results issues

#+begin_src sh
  echo output
#+end_src

This
#+begin_src sh
  echo output
#+end_src
text here

results in

t#+results:
: output
ext here

#+begin_src emacs-lisp
  (+ 1 1)
#+end_src

#+results:
: 2
** sh with sessions

#+begin_src sh :session eric
  cd ~/Desktop
#+end_src

#+begin_src sh :session eric
  cd ~/Desktop/clj/
  ls *.clj
#+end_src

#+results:
| "ants.clj" | "" | "concurrent.clj" | "" | "hello.clj" | "" | "spell-checker.clj" |

** testing srcname aliases

#+source: two
#+begin_src emacs-lisp
  2
#+end_src

#+begin_src emacs-lisp :var input=two
  (+ input 1)
#+end_src

#+results[1ec6c8d3de6aaeac7b2720f1d801402e762875ea]:
: 3

** hiding results
#+begin_src emacs-lisp
  (mapcar (lambda (el) (list el)) (number-sequence 0 20))
#+end_src

#+results:
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |

** elisp references

#+begin_src emacs-lisp :results silent
   (setq first 10)
#+end_src

#+srcname: resolve(name=nil)
#+begin_src emacs-lisp :results silent
  (eval (intern name))
#+end_src

#+begin_src python :var a=resolve(name="first")
  return a + 10
#+end_src

** elisp variables

#+begin_src ditaa :file (format "%d.png" 45)
      +-----------+
      |           |
      |           |
      |           |
      |           |
      +-----------+
#+end_src

#+results:
[[file:45.png]]
** haskell and tables
#+begin_src haskell
  sumListCond :: Int -> Int -> [Int] -> Int
  sumListCond l n xs
      | foldl (+) 0 (take l xs) <= n = sumListCond (l + 1) n xs
      | otherwise = foldl (+) 0 (take (l - 1) xs)
#+end_src
#+begin_src oz
  
#+end_src

** latex pngs
$x \mapsto y$

*** Theorem
$|consts(t)| \leq sizes(t)$

- by induction on the structure of t
- base cases are $t \in [true, false, 0]$: 
  - $|consts(t)| = |[t]| = 1 = size(t)$
- inductive size
  - $t \in [succ(t_1), pred(t_1), iszero(t_1)]$:
    - $|consts(t)| = |consts(t_1)| = |[t]| \leq size(t_1) < size(t)$
  - $t = if\, t_1 \, then \, t_2 \, else t_3$
    - $|consts(t)| = |consts(t_1) \cup consts(t_1) \cup consts(t_1)|$
    - $\leq |consts(t_1)| + |consts(t_1)| + |consts(t_1)|$
    - $\leq size(t_1) + size(t_1) + size(t_1)$
    - $< size(t)$

** indexing into gnuplot

#+tblname: squares
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |

#+begin_src gnuplot :var data=squares :results silent
plot data using 1:2 with lines
#+end_src

#+tblname: squares-with-sum
|  1 |  1 |
|  2 |  4 |
|  3 |  9 |
|  4 | 16 |
|  5 | 25 |
|  6 | 36 |
|----+----|
| 21 | 91 |

#+begin_src gnuplot :var data=squares-with-sum[0:-3] :results silent
  plot data using 1:2 with lines
#+end_src

** multiple arguments

#+begin_src emacs-lisp :var first=9 :var second=10
  (+ first second)
#+end_src

#+resname:
: 19

** indexing into results

#+tblname: indexable-table
| eric    |
| michael |
| schulte |
| is      |
| my      |
| name    |

#+begin_src emacs-lisp :var data=indexable-table[2:4]
   data
#+end_src

#+results:
| "schulte" |
| "is"      |
| "my"      |

#+tblname: multidimensional-indexing
| 1 |  2 |
| 3 |  4 |
| 5 |  6 |
| 7 |  8 |
| 9 | 10 |

#+begin_src emacs-lisp :var data=multidimensional-indexing[0:-2]
   data
#+end_src

#+resname:
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
| 7 | 8 |

** cached results
#+begin_src emacs-lisp :cache yes
   (setq org-babel-default-header-args '((:session . "none")
                                         (:results . "replace")
                                         (:exports . "code")(:cache)))
#+end_src

#+results[937269632ae5b5eee5c93f9eb50e0bc55e34520d]:
| (:session . none) | (:results . replace) | (:exports . code) | (:cache) |

#+srcname: eric-schulte
#+begin_src emacs-lisp :cache yes
   (+ 5 7 1)
#+end_src

#+results[005b04829608b3d22b61686e90309af3a9a6fe7c]: eric-schulte
: 13

#+begin_src ditaa :file caching-example.png
    +--------------------+
    |                    |     +-----------+
    |                    |     |           |
    |                    |     |           |
    |      +----+        |     |           |
    |      |    |        |     +-----------+
    |      +----+        |
    |                    |
    +--------------------+
#+end_src

#+results[fd11ddbfd00f6038e6e37db71ddaf43d65b0e200]:
[[file:caching-example.png]]

** switches and references

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

** unresolved noweb references

#+begin_src emacs-lisp :results silent
  (setq org-babel-noweb-error-langs '("ruby"))
#+end_src

#+srcname: i-have-a-name
#+begin_src ruby 
  1 + 2
#+end_src


#+begin_src ruby :noweb
  <<i-have-a-name>> + 3
#+end_src

#+resname:
: 6

** clojure
#+begin_src clojure :results silent
  (list 8 9)
#+end_src

** reference parts of tables

#+TBLNAME: squares
|  1 |   1 |
|  2 |   4 |
|  3 |   9 |
|  4 |  16 |
|  5 |  25 |
|  6 |  36 |
|  7 |  49 |
|  8 |  64 |
|  9 |  81 |
| 10 | 100 |
| 11 | 121 |
| 12 | 144 |
| 13 | 169 |
| 14 | 196 |
| 15 | 225 |
| 16 | 256 |
| 17 | 289 |
| 18 | 324 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=squares
set title "Implementing Gnuplot"
plot data using 1:2 with lines
#+end_src

** results switches
#+begin_src ruby :results output :results_switches -n
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example -n

-
--
---
----
-----
------
-------
--------
---------
#+end_example

#+begin_src ruby :results output
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example
  -
  --
  ---
  ----
  -----
  ------
  -------
  --------
  ---------
#+end_example

** xml and n3

introduce org-babel to =xml= and =n3=
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

** noweb referernces

#+srcname: noweb-example
#+begin_src ruby 
  a = 28
#+end_src

#+begin_src ruby :noweb
  # <<noweb-example>>
  a + 4
#+end_src

#+resname:
: 32

** =pp= results
*** python
#+begin_src python :results pp :session
  ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']
#+end_src

#+resname:
: ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']

*** ruby
#+begin_src ruby :results pp
  class Schulte
    attr_accessor :name, :age
  end
  
  eric = Schulte.new
  eric.name = "eric"
  eric.age = 27
  
  eric
#+end_src

#+resname:


#+begin_src ruby :results pp
  a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
  a
#+end_src

#+resname:
#+begin_example
[1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3]
#+end_example

** empty =output= results for emacs-lisp
#+begin_src emacs-lisp :results output
   8
#+end_src

#+resname:

** =:table= results param
#+begin_src emacs-lisp :results table
  8
#+end_src

#+resname:
| 8 |

** code results
*** emacs lisp
#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (lambda (item) (+ item el))) '(1 2 3 4 5))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
((lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el)))
#+END_SRC

#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (* el el)) '(1 2 3 89))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
(1 4 9 7921)
#+END_SRC

*** ruby

#+begin_src ruby :results code
  [1, 2, 33, 4].map{|n| "the number #{n}"}
#+end_src

#+resname:
#+BEGIN_SRC ruby
  ["the number 1", "the number 2", "the number 33", "the number 4"]
#+END_SRC

#+begin_src ruby :session :results code 
  [1, 2, 33, 4].map{|n| n + 10 }
#+end_src

#+resname:
#+BEGIN_SRC ruby
[11, 12, 43, 14]
#+END_SRC

*** python

#+begin_src python :results code
  ['one', 'two', 'three']
#+end_src

#+resname:
#+BEGIN_SRC python
['one', 'two', 'three']
#+END_SRC

#+begin_src python :results code
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

#+begin_src python :session :results code 
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

** indentation

#+begin_src python
          9
#+end_src

** persistent python
#+begin_src python :session :results silent
  import types
#+end_src

#+begin_src python :session
  types.FunctionType
#+end_src

#+resname:
: function

*** more persistent python
    :PROPERTIES:
    :session:  default
    :END:

#+begin_src python :results silent
  import types
#+end_src

#+begin_src python
  types.FunctionType
#+end_src

#+resname:
: function

** quoted latex

The following latex isn't exported correctly

#+begin_latex
  \begin{code}
  data BTree = Leaf a
             | Node Tree Tree
  \end{code}
#+end_latex

#+begin_src haskell
  data BTree = Leaf a
             | Node Tree Tree
#+end_src

** pretty print

#+begin_src emacs-lisp :results scalar
  '(1 2 3 4)
#+end_src

** simple scalar

#+begin_src emacs-lisp
  (+ 1 3)
#+end_src

#+resname:
: 4

** lua export

#+srcname: determine the neighbors of the segments that the bisector hits
#+begin_src lua :tangle no :exports code
  local s1, s2 = intersecting_segs[1], intersecting_segs[2]
  local n1 = table_find_segment(cell.neighbors, s1)
  local n2 = table_find_segment(cell.neighbors, s2)
#+end_src

I got:
#+begin_example
\lstset{language=lua}
\begin{lstlisting}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{lstlisting}
#+end_example

Emacs -Q got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

Emacs -Q + Org-babel got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

** simple R

#+begin_src R :session R
8
#+end_src

#+resname:
: 8

** changing source name

#+srcname: emacs-nine
#+begin_src emacs-lisp
  8
#+end_src

#+resname: emacs-nine
: 8

#+resname: emacs-eight
: 8

** advanced table
   | DATA             | WHAT       | WHERE       | HOW MUCH |
   |------------------+------------+-------------+----------|
   | [2009-09-25 Fri] |            |             |    28.95 |
   |------------------+------------+-------------+----------|
   |                  | food       | supermarket |     7.85 |
   |                  | ticket bus |             |      2.3 |
   |                  | tea + ice  | ice uno     |      4.4 |
   |                  | ticket     |             |     14.4 |
   |------------------+------------+-------------+----------|
   | [2009-09-26 Sat] |            |             |       41 |

#+begin_src emacs-lisp
  (let ((total 0) (responding t) purchases)
    (while responding
      (setq purchases
            (cons
             (list ""
                   (read-from-minibuffer "What: ")
                   (read-from-minibuffer "Where: ")
                   (read-minibuffer "How Much: "))
             purchases))
      (setq responding (y-or-n-p "more? ")))
    (append 
     purchases
     (list
      (list
       (format-time-string "%Y-%m-%d" (current-time))
       "" "" (progn
               (mapc (lambda (purchase)
                       (setq total (+ total (fourth purchase))))
                     purchases)
               total)))))
#+end_src

#+resname:
| ""           | "fish and chips" | "diner"  |  9.78 |
| ""           | "food"           | "subway" |  5.45 |
| "2009-09-29" | ""               | ""       | 15.23 |

** haskell
#+begin_src haskell
  powerSet :: [a] -> [[a]]
  powerSet = foldr (\ x ps -> map (\ y -> x : y) ps ++ ps ) [[]]
#+end_src

#+begin_src haskell
  powerSet [1, 2, 3]
#+end_src

** yasnippet
** indented
   #+begin_src emacs-lisp
     (message "I ran!!")   
   #+end_src

#+resname:
: I ran!!

** dynamic table
#+TBLNAME: todays-clock
#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
Clock summary at [2009-09-15 Tue 08:51], for Tuesday, September 15, 2009.

| L | Headline     | Time   |      |
|---+--------------+--------+------|
|   | *Total time* | *1:10* |      |
|---+--------------+--------+------|
| 1 | [[file:/Users/eschulte/Desktop/test.org::top][top]]          | 1:10   |    1 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]     |        | 1:00 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::later][later]]        |        | 0:10 |
#+END: clocktable

#+begin_src emacs-lisp :var data=todays-clock(1,1)
(message "table is %S" data)
#+end_src

#+resname:
: table is (("L" "Headline" "Time" "") hline ("" "*Total time*" "*1:10*" "") hline (1 "[[file:/Users/eschulte/Desktop/test.org::top][top]]" "1:10" 1) (2 "[[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]" "" "1:00") (2 "[[file:/Users/eschulte/Desktop/test.org::later][later]]" "" "0:10"))

#+begin_src R :session R-pie-example :var times=todays-clock :results silent
pie(times[2:length(times),4], labels = times[2:length(times),2])
#+end_src

** show all
   CLOCK: [2009-09-15 Tue 07:51]--[2009-09-15 Tue 08:51] =>  1:00
   :PROPERTIES:
   :exports:  both
   :END:

#+begin_src ditaa :file blue.png
   +----------------------+
   |                      |
   |                      |
   |          +-----------+
   |          |           |
   |          |           |
   |          |           |
   |          +-----------+
   |                      |
   +----------------------+
#+end_src
** later
   CLOCK: [2009-09-15 Tue 09:41]--[2009-09-15 Tue 09:51] =>  0:10
stuff here

** and then more
and more stuffs here
** asymptote

#+begin_src asymptote :file asymptote-test.png :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return 1+cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(a,0)$",(1,0),N);
  dot("$(2a,0)$",(2,0),N+E);
#+end_src

#+resname:
[[file:asymptote-test.png]]

** asymptote cosine
#+begin_src asymptote :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  for(int i=0; i < 8; ++i) {
    real j = 0.125 + 0.125*i;
    real h(real t) {return j;};
    path k=polargraph(h, -(acos(j)), acos(j), operator ..);
    draw(k,blue);
  }
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(pi,0)$",(1,0),N);
#+end_src

** gnuplot
#+begin_src gnuplot
plot cosx
#+end_src


* Babel-related code
*** Tangling without org-babel
    Not nice, but if libraries of code are going to be kept in org
    files, then one will sometimes need to load the code without using
    org-babel.
***** Perl script to tangle org-babel input
      This is a first pass; e.g. doesn't deal with :tangle header arg, etc.
#+begin_src perl 
#!/usr/bin/perl

$lang = shift ;
$lang or die "usage: $0 lang < file.org > file.lang\n" ;
$true = 1 ;
$false = 0 ;
$inblock = $false ;

while (<>) {
    if( $inblock ) {
	if( /^[ \t]*#\+end_src/ ) {
	    $inblock = $false ;
	    next ;
	}
	print ;
    }
    else {
	$inblock = /^[ \t]*#\+begin_src[ \t]+$lang/ ;
    }
}
#+end_src
***** R function to load org-babel R code
      This could also be done in pure R, without using an external script.
#+begin_src R 
  source.babel <- function(file)
      source(pipe(paste("org-babel-tangle.pl R", file)))
#+end_src
      
